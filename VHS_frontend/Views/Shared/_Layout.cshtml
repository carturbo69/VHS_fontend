@using Microsoft.Extensions.Configuration
@using Microsoft.AspNetCore.Http
@inject IConfiguration Configuration
<!-- Thêm Này Vào đề nữa đẩy lên cloud khỏi sửa đường dẫn -->

<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>@ViewData["Title"] - Viet Home Service</title>
    <link rel="icon" type="image/png" href="~/images/vhs_logo.png" />
    @Html.AntiForgeryToken()

    <!-- Font đẹp: Plus Jakarta Sans -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />

    <!-- CSS chung - ORDER MATTERS! notification.css trước, header.css sau để override -->
    <link rel="stylesheet" href="~/css/site.css" asp-append-version="true" />
    <!-- <link rel="stylesheet" href="~/css/about.css" asp-append-version="true" /> -->
    <link rel="stylesheet" href="~/css/footer.css" asp-append-version="true" />
    <link rel="stylesheet" href="~/css/notification.css" asp-append-version="true" />
    <!-- <link rel="stylesheet" href="~/css/service-shop.css" asp-append-version="true" /> -->
    <link rel="stylesheet" href="~/css/header.css" asp-append-version="true" /> <!-- MUST BE LAST to override everything -->
    
    <!-- CRITICAL FIX: Force color for notification item-time - Load after all CSS -->
    <style id="layout-notification-time-fix">
        /* ULTIMATE FIX: Force color cho item-time và notification-time-display - Light mode */
        .item-time,
        .item-time.notification-time-white,
        .item-time.vhs-time-display,
        .notification-time-display,
        .small.notification-time-display,
        #notificationDropdown .item-time,
        .notification-dropdown .item-time,
        .notification-items .item-time,
        .notification-item .item-time,
        .item-content .item-time,
        .notification-item .item-content .item-time,
        #notificationDropdown .notification-item .item-time,
        .notification-dropdown .notification-item .item-time,
        #notificationDropdown .item-content .item-time,
        .notification-dropdown .item-content .item-time,
        #notificationDropdown .notification-item .item-content .item-time,
        .notification-dropdown .notification-item .item-content .item-time,
        body #notificationDropdown .item-time,
        body .notification-dropdown .item-time,
        html body #notificationDropdown .item-time,
        html body .notification-dropdown .item-time {
            color: #334155 !important;
            -webkit-text-fill-color: #334155 !important;
            font-weight: 700 !important;
            font-size: 12px !important;
            opacity: 1 !important;
            filter: none !important;
            letter-spacing: 0.1px !important;
        }
        
        /* ULTIMATE FIX: Force color cho item-time trong dark mode - Priority cao nhất */
        .dark .item-time,
        .dark .item-time.notification-time-bright,
        .dark .item-time.notification-time-white,
        .dark .item-time.vhs-time-display,
        .dark .notification-time-display,
        .dark .small.notification-time-display,
        .dark #notificationDropdown .item-time,
        .dark .notification-dropdown .item-time,
        .dark .notification-items .item-time,
        .dark .notification-item .item-time,
        .dark .item-content .item-time,
        .dark .notification-item .item-content .item-time,
        .dark #notificationDropdown .notification-item .item-time,
        .dark .notification-dropdown .notification-item .item-time,
        .dark #notificationDropdown .item-content .item-time,
        .dark .notification-dropdown .item-content .item-time,
        .dark #notificationDropdown .notification-item .item-content .item-time,
        .dark .notification-dropdown .notification-item .item-content .item-time,
        .dark body #notificationDropdown .item-time,
        .dark body .notification-dropdown .item-time,
        .dark html body #notificationDropdown .item-time,
        .dark html body .notification-dropdown .item-time,
        html.dark .item-time,
        html.dark .notification-time-display,
        html.dark body .item-time,
        html.dark body #notificationDropdown .item-time,
        html.dark body .notification-dropdown .item-time {
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            font-weight: 700 !important;
            font-size: 12px !important;
            opacity: 1 !important;
            filter: none !important;
            letter-spacing: 0.1px !important;
            -webkit-font-smoothing: antialiased !important;
            -moz-osx-font-smoothing: grayscale !important;
        }
        
        /* Override Bootstrap text-muted cho notification time */
        .notification-time-display,
        .small.notification-time-display,
        .notification-menu .small.notification-time-display,
        #notificationMenu .small.notification-time-display {
            color: #334155 !important;
            opacity: 1 !important;
            font-weight: 700 !important;
        }
        
        .dark .notification-time-display,
        .dark .small.notification-time-display,
        .dark .notification-menu .small.notification-time-display,
        .dark #notificationMenu .small.notification-time-display {
            color: #ffffff !important;
            opacity: 1 !important;
            font-weight: 700 !important;
        }
    </style>


    @* THÊM DÒNG NÀY để các view bơm CSS riêng *@
    @RenderSection("Styles", required: false)

    <!-- CSS riêng cho trang Login/Register -->
    @if (ViewData["Title"]?.ToString() == "Đăng nhập" || ViewData["Title"]?.ToString() == "Đăng ký")
    {
        <link rel="stylesheet" href="~/css/auth.css" asp-append-version="true" />
    }
</head>
<body class="min-h-screen bg-background text-foreground font-sans antialiased">
    @await Html.PartialAsync("_Header")

    <main id="main">
        @RenderBody()
    </main>

    @if (ViewData["HideFooter"] == null || !(bool)ViewData["HideFooter"])
    {
        @await Html.PartialAsync("_Footer")
    }

    @* LẤY ACCOUNTID ĐỂ DÙNG CHO CHAT HUB *@
    @{
        var accIdClaim = User.FindFirst("AccountID")?.Value;
        var accIdSession = Context.Session.GetString("AccountID");
        var accId = !string.IsNullOrWhiteSpace(accIdClaim) ? accIdClaim : accIdSession;
    }


    <script>
        // Theme toggle
        (function () {
          const KEY = "vhs-theme";
          const root = document.documentElement;
          const saved = localStorage.getItem(KEY);
          const apply = t => t==="dark" ? root.classList.add("dark") : root.classList.remove("dark");
          if (saved==="light"||saved==="dark") apply(saved);
          else apply(matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
          window.__toggleTheme = function(){
            const next = root.classList.contains("dark") ? "light" : "dark";
            localStorage.setItem(KEY, next); apply(next);
          };
        })();

        // Smooth scroll cho anchor
        document.addEventListener("click", (e) => {
          const a = e.target.closest('a[href^="#"]');
          if (!a) return;
          const id = a.getAttribute("href");
          const el = document.querySelector(id);
          if (el) { e.preventDefault(); el.scrollIntoView({ behavior: "smooth", block: "start" }); }
        });

        // Header scroll effect - chỉ thêm shadow
        const header = document.querySelector('.site-header');
        if (header) {
            window.addEventListener('scroll', () => {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                // Thêm shadow khi scroll xuống
                if (scrollTop > 50) {
                    header.classList.add('scrolled');
                } else {
                    header.classList.remove('scrolled');
                }
            }, { passive: true });
        }
    </script>

    <!-- Notification System -->
    <script>
        // Biến lưu trữ thông báo từ API (giữ lại để các chỗ khác dùng)
        let notifications = [];
        let menuRendered = false; // Flag để biết menu đã được render chưa
        let btn = null;
        let menu = null;
        let hoverTimeout;

        // Đảm bảo đã có dữ liệu notifications trước khi render
        async function ensureNotificationsLoaded() {
            if (!notifications || notifications.length === 0) {
                console.debug('[Notification] notifications array empty, loading...');
                await loadNotifications(true);
            } else {
                console.debug('[Notification] notifications array already loaded', { length: notifications.length });
            }
            
            console.debug('[Notification] ensureNotificationsLoaded after load', {
                length: Array.isArray(notifications) ? notifications.length : 'n/a',
                sample: Array.isArray(notifications) && notifications.length ? notifications[0] : null
            });
        }

        // Khởi tạo sau khi DOM ready
        function initNotificationMenu() {
            btn = document.getElementById('notificationBtn');
            menu = document.getElementById('notificationMenu');
            
            if (!btn || !menu) {
                console.log('⚠️ Notification elements not found');
                return;
            }

            // Di chuyển menu ra khỏi thẻ <a> để không bị clip bởi container/overflow
            // (tương tự provider/admin đang làm). Giữ nguyên ID để các selector hoạt động.
            if (menu.parentElement !== document.body) {
                document.body.appendChild(menu);
            }

            // Ngăn click vào chuông chuyển trang (chỉ dùng hover)
            btn.addEventListener('click', (e) => e.preventDefault());

            const showMenu = async () => {
                console.debug('[Notification] showMenu start');
                await ensureNotificationsLoaded();
                renderNotificationMenu();

                // Đặt menu ra ngoài flow để tránh bị che (overflow hidden)
                const rect = btn.getBoundingClientRect();
                const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
                const menuWidth = Math.min(380, viewportWidth - 16);

                // Tính vị trí dựa trên tọa độ tuyệt đối của nút chuông (viewport)
                const top = rect.bottom + 8;
                const left = Math.min(
                    Math.max(rect.right - menuWidth, 8),
                    viewportWidth - menuWidth - 8
                );

                console.debug('[Notification] showMenu position', {
                    rect,
                    menuWidth,
                    top,
                    left
                });

                menu.classList.add('show');
                menu.style.position = 'fixed';
                menu.style.top = `${top}px`;
                menu.style.left = `${left}px`;
                menu.style.width = `${menuWidth}px`;
                menu.style.minWidth = `${menuWidth}px`;
                menu.style.maxHeight = '70vh';
                menu.style.display = 'block';
                menu.style.visibility = 'visible';
                menu.style.opacity = '1';
                menu.style.zIndex = '2000';
                menu.style.pointerEvents = 'auto';
            };

            const hideMenu = () => {
                menu.classList.remove('show');
                menu.style.display = 'none';
                menu.style.visibility = 'hidden';
                menu.style.opacity = '0';
            };

            // Hover để hiển thị (mở khi rê, không cần click)
            btn.addEventListener('mouseenter', async () => {
                clearTimeout(hoverTimeout);
                await showMenu();
            });

            // Giữ mở khi hover vào menu
            menu.addEventListener('mouseenter', () => {
                clearTimeout(hoverTimeout);
            });

            // Ẩn khi rời chuột khỏi btn và menu (delay nhỏ)
            const scheduleHide = () => {
                clearTimeout(hoverTimeout);
                hoverTimeout = setTimeout(() => hideMenu(), 120);
            };
            btn.addEventListener('mouseleave', scheduleHide);
            menu.addEventListener('mouseleave', scheduleHide);

            // Đóng khi click ra ngoài
            document.addEventListener('click', (e) => {
                if (!btn.contains(e.target) && !menu.contains(e.target)) {
                    hideMenu();
                }
            });

            // Đóng khi nhấn ESC
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') hideMenu();
            });
        }
        
        function normalizeNotification(n) {
            if (!n) return null;
            
            // Chuyển đổi IsRead về boolean (tránh trường hợp trả về "false"/"true" dạng string)
            const isReadRaw = n.isRead ?? n.IsRead ?? false;
            const isRead =
                typeof isReadRaw === 'string'
                    ? isReadRaw.toLowerCase() === 'true'
                    : !!isReadRaw;

            return {
                notificationId: n.notificationId || n.NotificationId || n.id || n.Id,
                content: n.content || n.Content || '',
                notificationType: (n.notificationType || n.NotificationType || '').toString(),
                createdAt: n.createdAt || n.CreatedAt || n.created_at || n.createdAtUtc || '',
                isRead
            };
        }

        // Render notification menu từ array notifications (hiển thị toàn bộ chưa đọc)
        function renderNotificationMenu() {
            if (!menu) return;
            
            menu.innerHTML = '';
            
            // Add header
            const header = document.createElement('div');
            header.className = 'dropdown-header';
            header.innerHTML = '<h3>Thông báo</h3>';
            menu.appendChild(header);
            
            const unreadNotifications = (notifications || [])
                .map(normalizeNotification)
                .filter(n => n && !n.isRead);

            console.debug('[Notification] renderNotificationMenu', {
                total: notifications ? notifications.length : 0,
                unread: unreadNotifications.length,
                sample: unreadNotifications.length ? unreadNotifications[0] : null
            });
            
            if (unreadNotifications.length === 0) {
                console.warn('[Notification] No unread notifications but menu opened', {
                    total: notifications ? notifications.length : 0,
                    notifications
                });
                const empty = document.createElement('li');
                empty.className = 'text-center text-muted py-2';
                empty.innerHTML = '<i class="bi bi-bell-slash me-2"></i>Không có thông báo nào';
                menu.appendChild(empty);
                return;
            }
            
            unreadNotifications.forEach(n => {
                const li = document.createElement('li');
                li.style.cursor = 'pointer';
                
                // Format time giống y trang thông báo
                const formattedTime = formatVietnamTime(n.createdAt);
                
                li.innerHTML = `
                    <div class="d-block text-decoration-none">
                        <div class="small notification-time-display" style="color: #334155 !important; font-weight: 700 !important; opacity: 1 !important;">${formattedTime}</div>
                        <div>${n.content}</div>
                        <div><strong>Loại:</strong> ${getNotificationTypeVN(n.notificationType)}</div>
                    </div>`;
                
                // Apply màu ngay sau khi tạo element
                const timeEl = li.querySelector('.notification-time-display');
                if (timeEl) {
                    const isDark = document.documentElement.classList.contains('dark') || document.body.classList.contains('dark');
                    const timeColor = isDark ? '#ffffff' : '#334155';
                    timeEl.style.setProperty('color', timeColor, 'important');
                    timeEl.style.setProperty('font-weight', '700', 'important');
                    timeEl.style.setProperty('opacity', '1', 'important');
                    timeEl.classList.remove('text-muted');
                }
                
                // Sử dụng addEventListener thay vì onclick để tránh mất handler
                li.addEventListener('click', function(e) {
                    markAsReadFromDropdown(n.notificationId, e);
                });
                
                menu.appendChild(li);
                
                // Apply lại sau khi append
                if (timeEl && typeof applyTimeStyle === 'function') {
                    setTimeout(applyTimeStyle, 0);
                }
            });
            
            // View all notifications button
            const all = document.createElement('li');
            all.innerHTML = `<a href="/Customer/Notification/Index" class="d-block text-center text-decoration-none">
                <i class="bi bi-arrow-right me-2"></i>Xem tất cả thông báo
            </a>`;
            menu.appendChild(all);
        }

        // Đếm và hiển thị badge (gọi API để tránh lệ thuộc biến notifications)
        async function loadUnreadCount() {
            const badge = document.getElementById('notificationBadge');
            if (!badge) {
                console.warn('⚠️ loadUnreadCount: #notificationBadge not found');
                return;
            }
            try {
                const resp = await fetch('/Customer/Notification/GetUnreadCount', { cache: 'no-store' });
                if (!resp.ok) {
                    console.warn('⚠️ loadUnreadCount response not OK:', resp.status);
                    badge.style.display = 'none';
                    return;
                }
                const data = await resp.json();
                const unreadCount = data?.count ?? 0;
                console.debug('[Notification] loadUnreadCount', { unreadCount, raw: data });
                if (unreadCount > 0) {
                    badge.textContent = unreadCount;
                    badge.style.display = 'inline-block';
                    badge.style.visibility = 'visible';
                    badge.style.opacity = '1';
                } else {
                    badge.style.display = 'none';
                    badge.textContent = '0';
                }
            } catch (error) {
                console.error('Error loadUnreadCount:', error);
                badge.style.display = 'none';
            }
        }

        // Helper to format Vietnam time - COPY Y TRANG THÔNG BÁO
        // C# backend: ToVietnamTime(notification.CreatedAt).ToString("dd/MM/yyyy HH:mm")
        // JS: formatVietnamTime(n.createdAt) → "dd/MM/yyyy HH:mm"
        function formatVietnamTime(dateString) {
            if (!dateString) return '';
            
            try {
                // API trả về UTC time (ví dụ: "2025-10-26T12:34:16.2974194")
                // Cần convert sang VN time (UTC+7)
                const date = new Date(dateString);
                
                // LUÔN LUÔN convert sang VN timezone
                const formatter = new Intl.DateTimeFormat('en-GB', {
                    timeZone: 'Asia/Ho_Chi_Minh',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });
                
                const parts = formatter.formatToParts(date);
                const day = parts.find(p => p.type === 'day')?.value || '00';
                const month = parts.find(p => p.type === 'month')?.value || '00';
                const year = parts.find(p => p.type === 'year')?.value || '0000';
                const hour = parts.find(p => p.type === 'hour')?.value || '00';
                const minute = parts.find(p => p.type === 'minute')?.value || '00';
                
                // Format: "dd/MM/yyyy HH:mm" (giống trang thông báo)
                return `${day}/${month}/${year} ${hour}:${minute}`;
            } catch (error) {
                console.error('Error formatting time:', error, dateString);
                return '';
            }
        }

        // Debounce và throttle để tránh gọi API quá nhiều lần
        let loadNotificationsTimeout = null;
        let isLoadingNotifications = false;
        let lastLoadTime = 0;
        const MIN_LOAD_INTERVAL = 2000; // Tối thiểu 2 giây giữa các lần gọi
        
        // Load danh sách thông báo từ API với debounce và throttle
        async function loadNotifications(force = false) {
            console.debug('[Notification] loadNotifications start', { force });
            
            // Nếu đang load thì bỏ qua
            if (isLoadingNotifications && !force) {
                console.debug('[Notification] loadNotifications skipped (isLoadingNotifications=true)');
                return;
            }
            
            // Throttle: Kiểm tra thời gian từ lần gọi cuối
            const now = Date.now();
            if (!force && (now - lastLoadTime) < MIN_LOAD_INTERVAL) {
                console.debug('[Notification] loadNotifications throttled', { delta: now - lastLoadTime });
                // Nếu chưa đủ thời gian, debounce lại
                if (loadNotificationsTimeout) {
                    clearTimeout(loadNotificationsTimeout);
                }
                loadNotificationsTimeout = setTimeout(() => {
                    loadNotifications(false);
                }, MIN_LOAD_INTERVAL - (now - lastLoadTime));
                return;
            }
            
            isLoadingNotifications = true;
            lastLoadTime = now;
            
            try {
                console.debug('[Notification] fetching /Customer/Notification/Unread ...');
                const response = await fetch('/Customer/Notification/Unread', { cache: 'no-store' });
                
                if (!response.ok) {
                    console.warn('[Notification] /Unread not OK', response.status);
                }
                
                const data = await response.json();

                // Chấp nhận nhiều format trả về: mảng thuần, {data|Data: [...]}, {data|Data:{items|Items:[...]}}, {notifications|Notifications:[...]}
                if (Array.isArray(data)) {
                    notifications = data;
                } else if (Array.isArray(data?.data)) {
                    notifications = data.data;
                } else if (Array.isArray(data?.Data)) {
                    notifications = data.Data;
                } else if (Array.isArray(data?.data?.items)) {
                    notifications = data.data.items;
                } else if (Array.isArray(data?.Data?.items)) {
                    notifications = data.Data.items;
                } else if (Array.isArray(data?.Data?.Items)) {
                    notifications = data.Data.Items;
                } else if (Array.isArray(data?.items)) {
                    notifications = data.items;
                } else if (Array.isArray(data?.Items)) {
                    notifications = data.Items;
                } else if (Array.isArray(data?.notifications)) {
                    notifications = data.notifications;
                } else if (Array.isArray(data?.Notifications)) {
                    notifications = data.Notifications;
                } else {
                    console.warn('[Notification] Unexpected response shape from /Unread', data);
                    notifications = [];
                }

                console.debug('[Notification] parsed notifications', {
                    rawType: typeof data,
                    isArray: Array.isArray(data),
                    fromDataArray: Array.isArray(data?.data),
                    fromNotificationsArray: Array.isArray(data?.notifications),
                    length: Array.isArray(notifications) ? notifications.length : 'n/a',
                    sample: Array.isArray(notifications) && notifications.length ? notifications[0] : null
                });
            } catch (error) {
                console.error('Error loading notifications:', error);
                notifications = [];
            } finally {
                isLoadingNotifications = false;
            }
            
            // Reset flag để render lại menu lần sau
            menuRendered = false;
        }

        // Helper function để convert NotificationType sang tiếng Việt
        function getNotificationTypeVN(type) {
            if (!type) return 'Khác';
            
            // Normalize type to handle case variations
            const normalizedType = type.trim();
            
            const types = {
                'PAYMENT_SUCCESS': 'Thanh toán thành công',
                'NEW_BOOKING': 'Đơn hàng mới',
                'BOOKING_CONFIRMED': 'Xác nhận đơn hàng',
                'BOOKING_CANCELLED': 'Hủy đơn hàng',
                'BOOKING_COMPLETED': 'Hoàn thành đơn hàng',
                'THANH TOÁN THÀNH CÔNG': 'Thanh toán thành công',
                'ĐƠN HÀNG MỚI': 'Đơn hàng mới',
                'Payment': 'Thanh toán',
                'Booking': 'Đặt lịch',
                'System': 'Hệ thống',
                'Promotion': 'Khuyến mãi',
                'Confirmed': 'Xác nhận',
                'Canceled': 'Bị hủy',
                'ServiceCompleted': 'Xác nhận hoàn thành',
                'Completed': 'Hoàn thành',
                'payment_success': 'Thanh toán thành công',
                'new_booking': 'Đơn hàng mới',
                // Case-insensitive matches
                'payment': 'Thanh toán',
                'booking': 'Đặt lịch',
                'system': 'Hệ thống',
                'promotion': 'Khuyến mãi',
                'confirmed': 'Xác nhận',
                'canceled': 'Bị hủy',
                'servicecompleted': 'Xác nhận hoàn thành',
                'completed': 'Hoàn thành'
            };
            
            // Try exact match first
            if (types[normalizedType]) {
                return types[normalizedType];
            }
            
            // Try case-insensitive match
            const lowerType = normalizedType.toLowerCase();
            for (const key in types) {
                if (key.toLowerCase() === lowerType) {
                    return types[key];
                }
            }
            
            return type;
        }

        // Mark notification as read from dropdown
        async function markAsReadFromDropdown(notificationId, event) {
            // Ngăn event bubbling để không trigger click trên dropdown
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            try {
                // Cập nhật badge ngay lập tức để UX tốt hơn
                const badge = document.getElementById('notificationBadge');
                if (badge && badge.style.display !== 'none') {
                    const currentCount = parseInt(badge.textContent) || 0;
                    if (currentCount > 1) {
                        badge.textContent = currentCount - 1;
                    } else {
                        badge.style.display = 'none';
                    }
                }
                
                // Đánh dấu notification đã đọc trong mảng local
                const notificationIndex = notifications.findIndex(n => n.notificationId === notificationId);
                if (notificationIndex !== -1) {
                    notifications[notificationIndex].isRead = true;
                }
                
                // Xóa notification khỏi dropdown ngay lập tức
                const clickedLi = event ? event.currentTarget : null;
                if (clickedLi && clickedLi.parentNode === menu) {
                    clickedLi.remove();
                    
                    // Nếu không còn notification nào, hiện thông báo "Không có"
                    const remainingLis = menu.querySelectorAll('li');
                    if (remainingLis.length === 1 && remainingLis[0].querySelector('a[href="/Customer/Notification/Index"]')) {
                        menu.innerHTML = '';
                        const header = document.createElement('div');
                        header.className = 'dropdown-header';
                        header.innerHTML = '<h3>Thông báo</h3>';
                        menu.appendChild(header);
                        const empty = document.createElement('li');
                        empty.className = 'text-center text-muted py-2';
                        empty.innerHTML = '<i class="bi bi-bell-slash me-2"></i>Không có thông báo nào';
                        menu.appendChild(empty);
                    }
                }
                
                // Gọi API để đánh dấu đã đọc và reset flag để load lại lần sau
                const tokenInput = document.querySelector('input[name="__RequestVerificationToken"]');
                if (tokenInput) {
                    const formData = new FormData();
                    formData.append('__RequestVerificationToken', tokenInput.value);
                    fetch(`/Customer/Notification/MarkRead/${notificationId}`, {
                        method: 'POST',
                        body: formData
                    }).then(() => {
                        menuRendered = false; // Reset để render lại menu lần sau
                        
                        // Thông báo cho trang notification nếu đang mở
                        notifyCustomerNotificationPage('markRead', { id: notificationId });
                    }).catch(error => {
                        console.error('Error marking notification as read:', error);
                    });
                }
            } catch (error) {
                console.error('Error in markAsReadFromDropdown:', error);
            }
        }

        // Mark tất cả đã đọc từ dropdown (Customer)
        async function markAllReadFromDropdown(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Tránh double-click
            if (window.__markingAllRead) return;
            window.__markingAllRead = true;
            
            try {
                const tokenInput = document.querySelector('input[name="__RequestVerificationToken"]');
                const formData = new FormData();
                if (tokenInput) {
                    formData.append('__RequestVerificationToken', tokenInput.value);
                }

                const resp = await fetch('/Customer/Notification/MarkAllRead', {
                    method: 'POST',
                    body: formData
                });

                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status}`);
                }

                // Cập nhật local state
                if (Array.isArray(notifications)) {
                    notifications = notifications.map(n => ({ ...n, isRead: true }));
                }

                // Cập nhật UI dropdown
                if (menu) {
                    menu.querySelectorAll('.notification-item.unread').forEach((item, idx) => {
                        setTimeout(() => {
                            item.classList.remove('unread');
                            const dot = item.querySelector('.notification-dot, .unread-dot');
                            if (dot) {
                                dot.style.opacity = '0';
                                setTimeout(() => dot.remove(), 200);
                            }
                        }, idx * 30);
                    });
                }

                // Ẩn badge
                const badge = document.getElementById('notificationBadge');
                if (badge) {
                    badge.textContent = '0';
                    badge.style.display = 'none';
                }

                // Reset flag để lần mở tiếp theo load lại server
                menuRendered = false;

                // Thông báo cho trang notification nếu đang mở
                notifyCustomerNotificationPage('markAllRead', {});
            } catch (err) {
                console.error('Error markAllReadFromDropdown:', err);
            } finally {
                window.__markingAllRead = false;
            }
        }
        
        // Function để thông báo cho trang notification khi có thay đổi
        function notifyCustomerNotificationPage(action, data) {
            console.log('[CustomerLayout] Notifying notification page:', action, data);
            
            // Nếu đang ở trang notification, trigger custom event để trang notification lắng nghe
            if (window.location.pathname.includes('/Customer/Notification')) {
                console.log('[CustomerLayout] Same page, dispatching custom event');
                window.dispatchEvent(new CustomEvent('notificationMarkedRead', {
                    detail: { action: action, data: data }
                }));
            }
            
            // Sử dụng BroadcastChannel để sync giữa các tabs/windows
            try {
                const channel = new BroadcastChannel('customer_notification_sync');
                channel.postMessage({
                    action: action,
                    data: data,
                    timestamp: Date.now()
                });
                console.log('[CustomerLayout] Sent via BroadcastChannel');
                channel.close();
            } catch (e) {
                console.log('[CustomerLayout] BroadcastChannel not supported, using localStorage fallback');
                // Fallback: sử dụng localStorage event
                localStorage.setItem('customer_notification_update', JSON.stringify({
                    action: action,
                    data: data,
                    timestamp: Date.now()
                }));
                localStorage.removeItem('customer_notification_update');
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            console.log('📬 Notification system initialized');
            // Khởi tạo menu event listeners
            initNotificationMenu();
            // Load thông báo khi trang load
            await loadNotifications();
            loadUnreadCount();
            
            // Cập nhật thông báo mỗi 30 giây
            setInterval(async () => {
                await loadNotifications();
                loadUnreadCount();
            }, 30000);
        });
        
        // Log khi script được load
        console.log('✅ Notification script loaded at:', new Date().toISOString());
    </script>


    <!-- CHAT UNREAD BADGE + SIGNALR CHAT HUB (THÊM MỚI) -->
    <script>
        // URL ChatHub lấy từ cấu hình backend (Apis:Backend) + /chathub
        const chatHubUrl = '@(Configuration["Apis:Backend"]?.TrimEnd('/') ?? "")/chathub';
        const currentAccountId = '@accId';

        // ================== CHAT UNREAD BADGE ==================
        async function loadChatUnreadCount() {
            const badge = document.getElementById("chatUnreadBadge");
            if (!badge) {
                console.warn("⚠️ Không tìm thấy #chatUnreadBadge trong DOM");
                return;
            }

            console.log("🔄 loadChatUnreadCount() gọi từ JS");

            try {
                const resp = await fetch("/Customer/ChatCustomer/UnreadTotal", {
                    method: "GET",
                    headers: {
                        "X-Requested-With": "XMLHttpRequest"
                    }
                });

                if (!resp.ok) {
                    console.warn("⚠️ loadChatUnreadCount response not OK:", resp.status);
                    badge.style.display = "none";
                    badge.textContent = "";
                    return;
                }

                const data = await resp.json();
                const total = (data && typeof data.total === "number") ? data.total : 0;

                console.log("✅ loadChatUnreadCount OK, total =", total);

                badge.style.display = "inline-block";
                badge.textContent = total;
            } catch (err) {
                console.error("❌ Error loading chat unread count:", err);
                const badge2 = document.getElementById("chatUnreadBadge");
                if (badge2) {
                    badge2.style.display = "inline-block";
                    badge2.textContent = "0";
                }
            }
        }

        // ================== SIGNALR CHAT HUB ==================
        document.addEventListener("DOMContentLoaded", async () => {
            console.log("📬 Chat unread + ChatHub system initialized");

            // Load badge chat lần đầu khi trang mở
            await loadChatUnreadCount();

            try {
                if (window.__chatHub) {
                    await window.__chatHub.start(chatHubUrl, currentAccountId);
                    console.log("✅ Chat hub started via __chatHub");

                    // Server bắn tổng số chưa đọc
                    window.__chatHub.on("totalUnread:update", payload => {
                        const total = (payload && typeof payload.total === "number") ? payload.total : 0;
                        const badge = document.getElementById("chatUnreadBadge");
                        if (!badge) return;

                        badge.style.display = "inline-block";
                        badge.textContent = total;

                        console.log("🔔 totalUnread:update từ SignalR =", total);
                    });

                    // Khi danh sách hội thoại thay đổi → reload lại tổng chưa đọc từ API
                    window.__chatHub.on("conversationList:update", async item => {
                        console.log("📥 conversationList:update (sẽ gọi loadChatUnreadCount)", item);
                        await loadChatUnreadCount();
                    });
                } else {
                    console.error("❌ window.__chatHub chưa được load");
                }
            } catch (err) {
                console.error("❌ Không kết nối được chatHub:", err);
            }

            // Fallback: mỗi 30s gọi lại (phòng trường hợp SignalR rớt)
            setInterval(async () => {
                await loadChatUnreadCount();
            }, 30000);
        });
    </script>

    <!-- SignalR Real-time Notifications for Customer -->
    <script>
        (function() {
          let notificationConnection = null;
          let isInitializing = false; // Flag để tránh khởi tạo nhiều lần

          async function initNotificationSignalR() {
            // Tránh khởi tạo nhiều lần
            if (isInitializing || notificationConnection) {
              console.log('[NotificationHub] Already initialized or initializing, skipping...');
              return;
            }
            
            isInitializing = true;
            
            try {
              // Load SignalR if not already loaded (may be loaded by chatbox)
              if (typeof signalR === 'undefined') {
                await new Promise((resolve, reject) => {
                  const script = document.createElement('script');
                  script.src = 'https://cdn.jsdelivr.net/npm/@@microsoft/signalr@8.0.0/dist/browser/signalr.min.js';
                  script.onload = resolve;
                  script.onerror = reject;
                  document.head.appendChild(script);
                });
              }

              // Get backend URL from meta tag or default
              const metaBackendUrl = document.querySelector('meta[name="backend-url"]')?.getAttribute('content');
              const backendUrl = metaBackendUrl || 'http://localhost:5154';
              const hubUrl = `${backendUrl}/hubs/notification`;

              // Create connection
              notificationConnection = new signalR.HubConnectionBuilder()
                .withUrl(hubUrl, {
                  skipNegotiation: false,
                  transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.ServerSentEvents | signalR.HttpTransportType.LongPolling
                })
                .withAutomaticReconnect({
                  nextRetryDelayInMilliseconds: retryContext => {
                    if (retryContext.elapsedMilliseconds < 60000) {
                      return 2000;
                    } else {
                      return 10000;
                    }
                  }
                })
                .configureLogging(signalR.LogLevel.Warning)
                .build();

              // Handle connection events
              notificationConnection.onreconnecting(() => {
                console.log('[NotificationHub] Reconnecting...');
              });

              notificationConnection.onreconnected(() => {
                console.log('[NotificationHub] Reconnected');
              });

              notificationConnection.onclose(() => {
                console.log('[NotificationHub] Connection closed');
              });

              // Listen for new notifications
              notificationConnection.on('ReceiveNotification', (notification) => {
                console.log('[NotificationHub] Received notification for Customer:', notification);
                handleNewNotification(notification);
              });

              // Start connection
              await notificationConnection.start();
              console.log('[NotificationHub] Connected successfully for Customer');
              isInitializing = false;

            } catch (error) {
              console.error('[NotificationHub] Error initializing SignalR for Customer:', error);
              isInitializing = false;
              // Reset connection để có thể thử lại sau
              notificationConnection = null;
            }
          }

          function handleNewNotification(notification) {
            if (!notification) return;

            // Add notification to local array if it exists
            if (typeof notifications !== 'undefined' && Array.isArray(notifications)) {
              notifications.unshift({
                notificationId: notification.notificationId || notification.NotificationId,
                content: notification.content || notification.Content,
                notificationType: notification.notificationType || notification.NotificationType,
                createdAt: notification.createdAt || notification.CreatedAt,
                isRead: false
              });

              // Update badge
              const badge = document.getElementById('notificationBadge');
              if (badge) {
                const unreadCount = notifications.filter(n => !n.isRead).length;
                if (unreadCount > 0) {
                  badge.textContent = unreadCount;
                  badge.style.display = 'inline-flex';
                } else {
                  badge.style.display = 'none';
                }
              }

              // Re-render menu if it's open
              if (typeof menuRendered !== 'undefined' && menuRendered && typeof renderNotificationMenu === 'function') {
                renderNotificationMenu();
              }
            }

            // Always reload from server to sync and update dropdown
            // Method 1: Use loadNotifications if available (updates array and re-renders)
            // Debounce để tránh gọi quá nhiều lần khi có nhiều notification cùng lúc
            if (typeof loadNotifications === 'function') {
              // Sử dụng debounce với delay 500ms
              if (loadNotificationsTimeout) {
                clearTimeout(loadNotificationsTimeout);
              }
              loadNotificationsTimeout = setTimeout(() => {
                loadNotifications(true).then(() => {
                  // Re-render menu after loading if it's open
                  if (typeof menuRendered !== 'undefined' && menuRendered && typeof renderNotificationMenu === 'function') {
                    renderNotificationMenu();
                  }
                });
              }, 500);
            }
            
            // Method 2: Also reload partial view HTML directly for immediate update
            const notificationMenu = document.getElementById('notificationMenu');
            if (notificationMenu) {
              fetch('/Customer/Notification/GetNotificationsPartial')
                .then(response => response.text())
                .then(html => {
                  // Update dropdown if it's visible
                  if (notificationMenu.style.display === 'block' || notificationMenu.offsetParent !== null) {
                    notificationMenu.innerHTML = html;
                    menuRendered = true; // Mark as rendered
                  }
                  // Always store the latest HTML for when dropdown is opened
                  notificationMenu.setAttribute('data-latest-html', html);
                })
                .catch(err => console.error('Error updating Customer notification dropdown:', err));
            }

            // Show toast notification
            showNotificationToast(notification);
          }

          function showNotificationToast(notification) {
            // Create toast notification
            const toast = document.createElement('div');
            toast.className = 'notification-toast';
            toast.style.cssText = 'position: fixed; top: 20px; right: 20px; min-width: 320px; max-width: 420px; background: white; border: 1px solid #e5e7eb; border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.15); z-index: 10000; opacity: 0; transform: translateX(400px); transition: all 0.3s ease;';
            toast.innerHTML = `
              <div style="display: flex; align-items: flex-start; gap: 12px; padding: 16px; position: relative;">
                <div style="flex-shrink: 0; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #10b981 0%, #34d399 100%); border-radius: 10px; color: white; font-size: 1.2rem;">
                  <i class="bi bi-bell-fill"></i>
                </div>
                <div style="flex: 1; min-width: 0;">
                  <div style="font-weight: 700; font-size: 0.95rem; color: #111827; margin-bottom: 4px;">Thông báo mới</div>
                  <div style="font-size: 0.875rem; color: #6b7280; line-height: 1.5; word-wrap: break-word;">${escapeHtml(notification.content || notification.Content || '')}</div>
                </div>
                <button onclick="this.parentElement.parentElement.remove()" style="position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; background: transparent; border: none; color: #6b7280; cursor: pointer; border-radius: 6px;">
                  <i class="bi bi-x"></i>
                </button>
              </div>
            `;
            
            document.body.appendChild(toast);
            
            // Animate in
            setTimeout(() => {
              toast.style.opacity = '1';
              toast.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
              toast.style.opacity = '0';
              toast.style.transform = 'translateX(400px)';
              setTimeout(() => toast.remove(), 300);
            }, 3000);
          }

          function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
          }

          // Initialize SignalR when page loads (chỉ một lần)
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
              // Wait a bit for notification system to initialize
              setTimeout(() => {
                initNotificationSignalR();
              }, 1000);
            });
          } else {
            // DOM đã sẵn sàng
            setTimeout(() => {
              initNotificationSignalR();
            }, 1000);
          }
          
          // Cleanup khi page unload
          window.addEventListener('beforeunload', () => {
            if (notificationConnection) {
              notificationConnection.stop();
              notificationConnection = null;
            }
          });

          // Cleanup on page unload
          window.addEventListener('beforeunload', () => {
            if (notificationConnection) {
              notificationConnection.stop();
            }
          });
        })();
    </script>

    @RenderSection("Scripts", required: false)
    
    <!-- Chatbox AI -->
    <link rel="stylesheet" href="~/css/chatbox.css" />
    @await Html.PartialAsync("_Chatbox")
    <!-- SignalR Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@@microsoft/signalr@8.0.0/dist/browser/signalr.min.js"></script>
    <script src="~/js/chat-hub-signalr.js" asp-append-version="true"></script>
    <script src="~/js/chatbox.js" type="text/javascript"></script>
    <!-- Translation System -->
    <script src="~/js/translate.js" asp-append-version="true"></script>
    
    <!-- ULTIMATE FIX: Inject CSS cho notification item-time - Load cuối cùng -->
    <style id="notification-time-ultimate-fix" data-priority="99999">
        /* ULTIMATE FIX: Force color cho item-time - Light mode */
        .item-time,
        .item-time.vhs-time-display,
        .item-time.notification-time-white,
        #notificationDropdown .item-time,
        .notification-dropdown .item-time,
        body .item-time,
        html body .item-time {
            color: #64748b !important;
            -webkit-text-fill-color: #64748b !important;
            font-weight: 600 !important;
            font-size: 12px !important;
            opacity: 1 !important;
            filter: none !important;
            letter-spacing: 0.1px !important;
        }
        
        /* ULTIMATE FIX: Force color cho item-time trong dark mode - Priority cao nhất */
        .dark .item-time,
        .dark .item-time.notification-time-bright,
        .dark .item-time.notification-time-white,
        .dark .item-time.vhs-time-display,
        .dark #notificationDropdown .item-time,
        .dark .notification-dropdown .item-time,
        .dark .notification-items .item-time,
        .dark .notification-item .item-time,
        .dark .item-content .item-time,
        .dark .notification-item .item-content .item-time,
        .dark #notificationDropdown .notification-item .item-time,
        .dark .notification-dropdown .notification-item .item-time,
        .dark #notificationDropdown .item-content .item-time,
        .dark .notification-dropdown .item-content .item-time,
        .dark #notificationDropdown .notification-item .item-content .item-time,
        .dark .notification-dropdown .notification-item .item-content .item-time,
        .dark body #notificationDropdown .item-time,
        .dark body .notification-dropdown .item-time,
        .dark html body #notificationDropdown .item-time,
        .dark html body .notification-dropdown .item-time,
        .dark html.dark body #notificationDropdown .item-time,
        .dark html.dark body .notification-dropdown .item-time,
        html.dark .item-time,
        html.dark body .item-time,
        html.dark body #notificationDropdown .item-time,
        html.dark body .notification-dropdown .item-time {
            color: #e2e8f0 !important;
            -webkit-text-fill-color: #e2e8f0 !important;
            font-weight: 600 !important;
            font-size: 12px !important;
            opacity: 1 !important;
            filter: none !important;
            letter-spacing: 0.1px !important;
            -webkit-font-smoothing: antialiased !important;
            -moz-osx-font-smoothing: grayscale !important;
        }
    </style>
    
    <script>
        console.log('=== Layout script section loaded ===');
        console.log('DOM state:', document.readyState);
        
        // Force apply style ngay khi script load
        (function() {
            function isDarkMode() {
                return document.documentElement.classList.contains('dark') || 
                       document.body.classList.contains('dark');
            }
            
            function applyTimeStyle() {
                const isDark = isDarkMode();
                const lightColor = '#334155';
                const darkColor = '#ffffff';
                const targetColor = isDark ? darkColor : lightColor;
                
                const items = document.querySelectorAll('.item-time, .vhs-time-display, .notification-time-white, .notification-time-display, .small.notification-time-display, .notification-menu .small, #notificationMenu .small, #notificationDropdown .item-time, .notification-dropdown .item-time, .notification-item .item-content .item-time, .notification-item .item-content span.item-time');
                items.forEach(function(el) {
                    // Xóa style cũ về color
                    el.style.cssText = el.style.cssText.replace(/color\s*:[^;]+;?/gi, '');
                    el.style.cssText = el.style.cssText.replace(/-webkit-text-fill-color\s*:[^;]+;?/gi, '');
                    
                    // Xóa class text-muted nếu có
                    el.classList.remove('text-muted');
                    
                    // Force apply với nhiều cách
                    el.style.color = targetColor;
                    el.style.setProperty('color', targetColor, 'important');
                    el.style.setProperty('-webkit-text-fill-color', targetColor, 'important');
                    el.style.setProperty('font-weight', '700', 'important');
                    el.style.setProperty('font-size', '12px', 'important');
                    el.style.setProperty('opacity', '1', 'important');
                    el.style.setProperty('-webkit-font-smoothing', 'antialiased', 'important');
                    el.style.setProperty('-moz-osx-font-smoothing', 'grayscale', 'important');
                    el.style.setProperty('letter-spacing', '0.1px', 'important');
                    el.style.setProperty('filter', 'none', 'important');
                });
            }
            
            // Chạy ngay
            applyTimeStyle();
            
            // Chạy lại nhiều lần
            [10, 50, 100, 200, 500, 1000, 2000].forEach(function(delay) {
                setTimeout(applyTimeStyle, delay);
            });
            
            // Chạy khi DOM ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', applyTimeStyle);
            }
            
            // Quan sát thay đổi DOM
            const observer = new MutationObserver(function() {
                applyTimeStyle();
            });
            
            observer.observe(document.documentElement, {
                attributes: true,
                attributeFilter: ['class']
            });
            
            if (document.body) {
                observer.observe(document.body, {
                    attributes: true,
                    attributeFilter: ['class']
                });
            }
            
            // Listen for theme changes
            window.addEventListener('themeChanged', applyTimeStyle);
            window.addEventListener('theme-toggle', applyTimeStyle);
            
            applyTimeStyle();
            setTimeout(applyTimeStyle, 100);
            setTimeout(applyTimeStyle, 500);
        })();
    </script>
</body>
</html>
