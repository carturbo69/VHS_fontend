@model VHS_frontend.Areas.Provider.Models.Service.ServiceProviderUpdateDTO
@{
    ViewData["Title"] = "Ch·ªânh s·ª≠a D·ªãch v·ª•";
    Layout = "~/Areas/Provider/Views/_ProviderLayout.cshtml";
    var serviceId = ViewBag.ServiceId as string;
    var currentImageUrl = ViewBag.CurrentImageUrl as string;
    var categoryName = ViewBag.CategoryName as string;
    var tags = ViewBag.Tags as List<VHS_frontend.Areas.Provider.Models.Service.TagDTO> ?? new List<VHS_frontend.Areas.Provider.Models.Service.TagDTO>();
    var options = ViewBag.Options as List<VHS_frontend.Areas.Provider.Models.Service.OptionDTO> ?? new List<VHS_frontend.Areas.Provider.Models.Service.OptionDTO>();
}

@section Styles {
    <link rel="stylesheet" href="~/css/service-management.css" asp-append-version="true" />
}

<div class="service-management-container">
    <!-- Header Card -->
    <div class="card shadow-sm mb-3 create-page-header">
        <div class="card-body">
            <div class="d-flex justify-content-between align-items-center">
                <h4 class="mb-0">
                    <i class="bi bi-pencil me-2"></i>
                    Ch·ªânh s·ª≠a D·ªãch v·ª•
                </h4>
                <a asp-action="Index" class="btn btn-secondary btn-sm">
                    <i class="bi bi-arrow-left me-1"></i>
                    Quay l·∫°i
                </a>
            </div>
        </div>
    </div>

    @if (TempData["Error"] != null)
    {
        <div class="alert alert-danger alert-dismissible fade show" role="alert">
            @TempData["Error"]
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    }

    <!-- Form Card -->
    <div class="card shadow-sm form-card">
        <div class="card-header form-card-header">
            <h6 class="mb-0">
                <i class="bi bi-info-circle me-2"></i>
                Th√¥ng tin D·ªãch v·ª•
            </h6>
        </div>
        <div class="card-body">
            <form asp-action="Edit" asp-route-id="@serviceId" method="post" enctype="multipart/form-data" id="editServiceForm" novalidate>
                @Html.AntiForgeryToken()

                <script>
                    // Validation functions - must be defined before form fields
                    // H√†m l·∫•y gi·ªõi h·∫°n min/max d·ª±a tr√™n ƒë∆°n v·ªã (theo lu·∫≠t lao ƒë·ªông)
                    function getUnitLimits(unitType) {
                        const limits = {
                            'Hour': { min: 1, max: 8, message: 'Gi·ªù l√†m vi·ªác t·ªëi ƒëa 8 gi·ªù/ng√†y theo lu·∫≠t lao ƒë·ªông.' },
                            'Day': { min: 1, max: 7, message: 'S·ªë ng√†y t·ªëi ƒëa 7 ng√†y/tu·∫ßn theo lu·∫≠t lao ƒë·ªông.' },
                            'Visit': { min: 1, max: 10, message: 'S·ªë l·∫ßn t·ªëi ƒëa 10 l·∫ßn.' },
                            'Apartment': { min: 1, max: 10, message: 'S·ªë cƒÉn t·ªëi ƒëa 10 cƒÉn.' },
                            'Room': { min: 1, max: 50, message: 'S·ªë ph√≤ng t·ªëi ƒëa 50 ph√≤ng.' },
                            'SquareMeter': { min: 1, max: 1000, message: 'Di·ªán t√≠ch t·ªëi ƒëa 1000 m¬≤.' },
                            'Person': { min: 1, max: 100, message: 'S·ªë ng∆∞·ªùi t·ªëi ƒëa 100 ng∆∞·ªùi.' },
                            'Package': { min: 1, max: 10, message: 'S·ªë g√≥i t·ªëi ƒëa 10 g√≥i.' },
                            'Event': { min: 1, max: 5, message: 'S·ªë s·ª± ki·ªán t·ªëi ƒëa 5 s·ª± ki·ªán.' }
                        };
                        return limits[unitType] || { min: 1, max: 100, message: 'S·ªë l∆∞·ª£ng t·ªëi ƒëa 100.' };
                    }

                    // C·∫≠p nh·∫≠t min/max v√† placeholder cho BaseUnit khi ƒë∆°n v·ªã thay ƒë·ªïi
                    function updateBaseUnitLimits() {
                        const unitTypeSelect = document.getElementById('unitTypeSelect');
                        const baseUnitField = document.getElementById('BaseUnit');
                        const baseUnitError = document.getElementById('baseUnitError');
                        
                        if (!unitTypeSelect || !baseUnitField) return;
                        
                        const unitType = unitTypeSelect.value;
                        if (!unitType) {
                            baseUnitField.min = 1;
                            baseUnitField.max = 100;
                            baseUnitField.placeholder = '1';
                            if (baseUnitError) {
                                baseUnitError.textContent = 'Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu (t·ª´ 1 tr·ªü l√™n).';
                            }
                            return;
                        }
                        
                        const limits = getUnitLimits(unitType);
                        baseUnitField.min = limits.min;
                        baseUnitField.max = limits.max;
                        baseUnitField.placeholder = limits.min.toString();
                        if (baseUnitError) {
                            baseUnitError.textContent = `S·ªë l∆∞·ª£ng ph·∫£i t·ª´ ${limits.min} ƒë·∫øn ${limits.max}. ${limits.message}`;
                        }
                        
                        // Validate l·∫°i gi√° tr·ªã hi·ªán t·∫°i
                        if (baseUnitField.value) {
                            validateBaseUnitWithUnitType(baseUnitField);
                        }
                    }

                    // Validate BaseUnit v·ªõi gi·ªõi h·∫°n theo ƒë∆°n v·ªã
                    function validateBaseUnitWithUnitType(field) {
                        const unitTypeSelect = document.getElementById('unitTypeSelect');
                        const baseUnitError = document.getElementById('baseUnitError');
                        
                        if (!unitTypeSelect || !unitTypeSelect.value) {
                            field.setCustomValidity('Vui l√≤ng ch·ªçn ƒë∆°n v·ªã tr∆∞·ªõc.');
                            return;
                        }
                        
                        const unitType = unitTypeSelect.value;
                        const limits = getUnitLimits(unitType);
                        const value = parseFloat(field.value);
                        
                        if (!field.value || field.value === '' || field.value === null || field.value === undefined) {
                            field.setCustomValidity('Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu.');
                            field.classList.add('is-invalid');
                            if (baseUnitError) baseUnitError.textContent = 'Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu.';
                        } else if (isNaN(value)) {
                            field.setCustomValidity('Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá.');
                            field.classList.add('is-invalid');
                            if (baseUnitError) baseUnitError.textContent = 'Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá.';
                        } else if (value < limits.min) {
                            field.setCustomValidity(`S·ªë l∆∞·ª£ng ph·∫£i t·ª´ ${limits.min} tr·ªü l√™n.`);
                            field.classList.add('is-invalid');
                            if (baseUnitError) baseUnitError.textContent = `S·ªë l∆∞·ª£ng ph·∫£i t·ª´ ${limits.min} tr·ªü l√™n.`;
                        } else if (value > limits.max) {
                            field.setCustomValidity(limits.message);
                            field.classList.add('is-invalid');
                            if (baseUnitError) baseUnitError.textContent = limits.message;
                        } else {
                            field.setCustomValidity('');
                            field.classList.remove('is-invalid');
                        }
                    }

                    function validateBaseUnit(field) {
                        validateBaseUnitWithUnitType(field);
                    }
                </script>

                <div class="row g-3">
                    <!-- Category (Read-only) -->
                    <div class="col-md-6">
                        <label class="form-label">Danh m·ª•c</label>
                        <input type="text" class="form-control" value="@categoryName" readonly />
                        <small class="form-text text-muted small">Danh m·ª•c kh√¥ng th·ªÉ thay ƒë·ªïi sau khi t·∫°o.</small>
                    </div>

                    <!-- Tag Selection -->
                    <div class="col-md-6">
                        <label class="form-label">Tag <span class="text-danger">*</span></label>
                        <!-- Selected Tag Display (hi·ªÉn th·ªã trong khung gi·ªëng category) -->
                        <div id="selectedTagDisplay" class="@(Model.TagIds.Any() ? "" : "d-none")">
                            <div class="input-group">
                                <input type="text" class="form-control" id="selectedTagName" value="@(tags.FirstOrDefault(t => Model.TagIds.Contains(t.TagId))?.Name ?? "")" readonly />
                                <button type="button" class="btn btn-outline-secondary" id="removeSelectedTagBtn" title="X√≥a tag">
                                    <i class="bi bi-x-lg"></i>
                                </button>
                            </div>
                        </div>
                        <div class="form-input-wrapper">
                            <select class="form-select @(Model.TagIds.Any() ? "d-none" : "")" id="tagSelect" required>
                                <option value="">-- Ch·ªçn tag --</option>
                            </select>
                            <div class="invalid-feedback">Vui l√≤ng ch·ªçn tag.</div>
                        </div>
                        <small class="form-text text-muted small">Ch·ªçn tag ƒë·ªÉ xem c√°c t√πy ch·ªçn</small>
                        <input type="hidden" name="TagIds" id="selectedTagId" value="@(Model.TagIds.FirstOrDefault().ToString() ?? "")" />
                    </div>
                </div>

                <!-- Title - Hidden, t·ª± ƒë·ªông l·∫•y t·ª´ tag -->
                <input type="hidden" asp-for="Title" id="titleInput" />

                <!-- Options Section (Options hi·ªÉn th·ªã ·ªü d∆∞·ªõi) -->
                <div class="mt-3" id="selectedOptionsSection" style="display: @(Model.OptionIds.Any() ? "block" : "none");">
                    <label class="form-label fw-bold section-label">
                        <i class="bi bi-list-check me-2"></i>
                        T√πy ch·ªçn
                    </label>
                    <div id="selectedOptionsContainer" class="p-3 border rounded">
                        <!-- T·∫•t c·∫£ options c·ªßa c√°c tags ƒë√£ ch·ªçn s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
                    </div>
                </div>

                <!-- Description -->
                <div class="mt-3">
                    <label asp-for="Description" class="form-label">M√¥ t·∫£ <span class="text-danger">*</span></label>
                    <div class="form-input-wrapper">
                        <textarea asp-for="Description" name="Description" id="Description" class="form-control" rows="5" maxlength="3000" placeholder="V√≠ d·ª•: D·ªãch v·ª• d·ªçn d·∫πp nh√† c·ª≠a chuy√™n nghi·ªáp bao g·ªìm:
- Qu√©t d·ªçn, lau ch√πi to√†n b·ªô ph√≤ng kh√°ch, ph√≤ng ng·ªß, nh√† b·∫øp, nh√† v·ªá sinh
- Th·ªùi gian: 2-3 gi·ªù/ l·∫ßn, c√≥ th·ªÉ ƒë·∫∑t l·ªãch linh ho·∫°t theo y√™u c·∫ßu
- ƒê·ªãa ƒëi·ªÉm: T·∫°i nh√† kh√°ch h√†ng
- Cam k·∫øt: ƒê·∫£m b·∫£o s·∫°ch s·∫Ω, g·ªçn g√†ng, an to√†n cho s·ª©c kh·ªèe,..." 
                              data-val="true" 
                              data-val-required="Vui l√≤ng nh·∫≠p m√¥ t·∫£ d·ªãch v·ª•."
                              data-val-maxlength="M√¥ t·∫£ kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 3000 k√Ω t·ª±."
                              data-val-maxlength-max="3000"
                              required
                              oninvalid="this.setCustomValidity('Vui l√≤ng nh·∫≠p m√¥ t·∫£ d·ªãch v·ª•.')"
                              oninput="this.setCustomValidity(''); this.classList.remove('is-invalid'); updateDescriptionCharCount(this);"></textarea>
                        <div class="invalid-feedback">Vui l√≤ng nh·∫≠p m√¥ t·∫£ d·ªãch v·ª•.</div>
                    </div>
                    <div class="d-flex justify-content-between align-items-center mt-1">
                        <small class="form-text text-muted small">
                            <i class="bi bi-info-circle me-1"></i>
                            <strong>G·ª£i √Ω:</strong> M√¥ t·∫£ chi ti·∫øt v·ªÅ quy tr√¨nh, th·ªùi gian, ƒë·ªãa ƒëi·ªÉm, y√™u c·∫ßu ƒë·∫∑c bi·ªát. M√¥ t·∫£ c√†ng r√µ r√†ng s·∫Ω gi√∫p kh√°ch h√†ng hi·ªÉu v√† tin t∆∞·ªüng d·ªãch v·ª• c·ªßa b·∫°n h∆°n.
                        </small>
                        <small class="form-text text-muted text-end" id="descriptionCharCount" style="font-size: 0.75rem;">0/3000 k√Ω t·ª±</small>
                    </div>
                </div>

                <div class="row g-3 mt-0">
                    <!-- Price -->
                    <div class="col-md-4">
                        <label asp-for="Price" class="form-label">Gi√° (VNƒê) <span class="text-danger">*</span></label>
                        <div class="form-input-wrapper">
                            <input asp-for="Price" asp-format="{0:0}" type="number" class="form-control" id="Price" min="20000" max="100000000" step="1000" placeholder="20000" required />
                            <div class="invalid-feedback">Gi√° ph·∫£i t·ª´ 20.000 ƒë·∫øn 100.000.000 VNƒê v√† l√† b·ªôi s·ªë c·ªßa 1.000.</div>
                        </div>
                        <small class="form-text text-muted small">
                            <i class="bi bi-info-circle me-1"></i>
                            Gi√° t·ªëi thi·ªÉu: 20.000 VNƒê, t·ªëi ƒëa: 100.000.000 VNƒê. Ph·∫£i l√† b·ªôi s·ªë c·ªßa 1.000.
                        </small>
                    </div>

                    <!-- Unit Type -->
                    <div class="col-md-4">
                        <label asp-for="UnitType" class="form-label">
                            <i class="bi bi-rulers me-1"></i>ƒê∆°n v·ªã <span class="text-danger">*</span>
                        </label>
                        <div class="form-input-wrapper">
                            <select asp-for="UnitType" class="form-select" id="unitTypeSelect" required>
                                <option value="">-- Ch·ªçn ƒë∆°n v·ªã --</option>
                                <option value="Hour">Gi·ªù</option>
                                <option value="Day">Ng√†y</option>
                                <option value="Visit">L·∫ßn</option>
                                <option value="Apartment">CƒÉn</option>
                                <option value="Room">Ph√≤ng</option>
                                <option value="SquareMeter">M√©t vu√¥ng (m¬≤)</option>
                                <option value="Person">Ng∆∞·ªùi</option>
                                <option value="Package">G√≥i</option>
                                <option value="Event">S·ª± ki·ªán</option>
                            </select>
                            <div class="invalid-feedback">Vui l√≤ng ch·ªçn ƒë∆°n v·ªã.</div>
                        </div>
                    </div>

                    <!-- Base Unit -->
                    <div class="col-md-4">
                        <label asp-for="BaseUnit" class="form-label">
                            <i class="bi bi-123 me-1"></i>S·ªë l∆∞·ª£ng <span class="text-danger">*</span>
                        </label>
                        <div class="form-input-wrapper">
                            <input asp-for="BaseUnit" name="BaseUnit" id="BaseUnit" type="number" class="form-control" min="1" max="100" step="1" placeholder="1" 
                                   data-val="true" 
                                   data-val-required="Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu."
                                   data-val-min="S·ªë l∆∞·ª£ng ph·∫£i t·ª´ 1 tr·ªü l√™n."
                                   data-val-min-min="1"
                                   required
                                   oninvalid="validateBaseUnit(this)"
                                   oninput="validateBaseUnitWithUnitType(this); this.classList.remove('is-invalid');" />
                            <div class="invalid-feedback" id="baseUnitError">Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu (t·ª´ 1 tr·ªü l√™n).</div>
                        </div>
                    </div>
                </div>

                <!-- Status -->
                <div class="mt-3">
                    @{
                        var currentStatus = ViewBag.CurrentStatus as string ?? Model.Status;
                        var isPendingStatus = string.Equals(currentStatus, "Pending", StringComparison.OrdinalIgnoreCase) ||
                                             string.Equals(currentStatus, "PendingUpdate", StringComparison.OrdinalIgnoreCase);
                        var isInactiveStatus = string.Equals(currentStatus, "Inactive", StringComparison.OrdinalIgnoreCase);
                    }
                    
                    @if (isPendingStatus)
                    {
                        <!-- ·∫®n field Status n·∫øu ƒëang ch·ªù duy·ªát, ch·ªâ hi·ªÉn th·ªã th√¥ng b√°o -->
                        <input type="hidden" asp-for="Status" value="@currentStatus" />
                        <label class="form-label">Tr·∫°ng th√°i</label>
                        <div class="alert alert-warning mb-0">
                            <i class="bi bi-info-circle me-2"></i>
                            <strong>D·ªãch v·ª• ƒëang ch·ªù duy·ªát</strong>
                            @if (string.Equals(currentStatus, "Pending", StringComparison.OrdinalIgnoreCase))
                            {
                                <span class="badge bg-warning text-dark ms-2">Ch·ªù duy·ªát</span>
                            }
                            else if (string.Equals(currentStatus, "PendingUpdate", StringComparison.OrdinalIgnoreCase))
                            {
                                <span class="badge bg-warning text-dark ms-2">Ch·ªù duy·ªát ch·ªânh s·ª≠a</span>
                            }
                            <br />
                            <small>Khi b·∫°n c·∫≠p nh·∫≠t d·ªãch v·ª•, tr·∫°ng th√°i s·∫Ω v·∫´n l√† "Ch·ªù duy·ªát" cho ƒë·∫øn khi admin duy·ªát.</small>
                        </div>
                    }
                    else if (isInactiveStatus)
                    {
                        <!-- N·∫øu ƒëang t·∫°m d·ª´ng, ·∫©n field Status v√† hi·ªÉn th·ªã th√¥ng b√°o -->
                        <input type="hidden" asp-for="Status" value="Pending" />
                        <label class="form-label">Tr·∫°ng th√°i</label>
                        <div class="alert alert-info mb-0">
                            <i class="bi bi-info-circle me-2"></i>
                            <strong>D·ªãch v·ª• ƒëang t·∫°m d·ª´ng</strong>
                            <span class="badge bg-secondary ms-2">T·∫°m d·ª´ng</span>
                            <br />
                            <small>Khi b·∫°n c·∫≠p nh·∫≠t d·ªãch v·ª•, tr·∫°ng th√°i s·∫Ω t·ª± ƒë·ªông chuy·ªÉn th√†nh <strong>"Ch·ªù duy·ªát"</strong> v√† c·∫ßn admin duy·ªát l·∫°i tr∆∞·ªõc khi ho·∫°t ƒë·ªông.</small>
                        </div>
                    }
                    else
                    {
                        <!-- Hi·ªÉn th·ªã select Status b√¨nh th∆∞·ªùng n·∫øu ƒëang ho·∫°t ƒë·ªông -->
                        <label asp-for="Status" class="form-label">Tr·∫°ng th√°i</label>
                        <select asp-for="Status" class="form-select">
                            <option value="Active">Ho·∫°t ƒë·ªông</option>
                            <option value="Inactive">T·∫°m d·ª´ng</option>
                        </select>
                        <span asp-validation-for="Status" class="text-danger small"></span>
                    }
                </div>

                <!-- Images (G·ªôp avatar + ·∫£nh m√¥ t·∫£) -->
                <div class="mt-3">
                    <label class="form-label">H√¨nh ·∫£nh d·ªãch v·ª•</label>
                    @{
                        var imagesCsv = currentImageUrl ?? string.Empty;
                        var imgs = imagesCsv.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries).ToList();
                        var avatar = imgs.FirstOrDefault();
                        var descImgs = imgs.Skip(1).ToList();
                        var backendBase = ViewBag.BackendBase as string ?? "http://localhost:5154";
                        string ToUrl(string? p) => string.IsNullOrEmpty(p) ? string.Empty : (p.StartsWith("http") ? p : $"{backendBase.TrimEnd('/')}/{p.TrimStart('/')}");
                    }

                    <!-- H√¨nh ·∫£nh hi·ªán t·∫°i (g·ªôp avatar + m√¥ t·∫£) -->
                    <div class="mb-2">
                        <div class="image-inline-gallery" id="imageGalleryContainer">
                            @if (!string.IsNullOrEmpty(avatar))
                            {
                                var avatarUrl = ToUrl(avatar);
                                <div class="removable-image" data-path="@avatar">
                                    <img src="@avatarUrl" alt="Avatar"
                                         onerror="this.onerror=null; this.parentElement.innerHTML='<div class=\'alert alert-warning\'>Kh√¥ng th·ªÉ t·∫£i ·∫£nh</div>';" />
                                    <button type="button" class="btn btn-sm btn-danger remove-image-btn" title="Xo√° ·∫£nh" aria-label="Xo√° ·∫£nh">
                                        <i class="bi bi-x-lg"></i>
                                    </button>
                                </div>
                            }
                            @if (descImgs.Any())
                            {
                                foreach (var p in descImgs)
                                {
                                    var u = ToUrl(p);
                                    <div class="removable-image" data-path="@p">
                                        <img src="@u" alt="Desc"
                                             onerror="this.onerror=null; this.parentElement.innerHTML='<div class=\'alert alert-warning p-2\'>L·ªói ·∫£nh</div>';" />
                                        <button type="button" class="btn btn-sm btn-danger remove-image-btn" title="Xo√° ·∫£nh" aria-label="Xo√° ·∫£nh">
                                            <i class="bi bi-x-lg"></i>
                                        </button>
                                    </div>
                                }
                            }
                        </div>
                        <!-- Hidden inputs for removed images -->
                        <div id="removedImagesContainer"></div>
                        <!-- Hidden input to store current images (for keeping old images when no new images are uploaded) -->
                        <input type="hidden" id="currentImagesData" value="@currentImageUrl" />
                        <div class="file-input-wrapper">
                            <input name="Images" type="file" id="imageInputEdit" class="form-control mt-3" accept="image/*" multiple />
                        </div>
                        <span asp-validation-for="Images" class="text-danger small"></span>
                        <small class="form-text text-muted small">Ch·ªçn 1 ho·∫∑c nhi·ªÅu ·∫£nh m·ªõi. ·∫¢nh m·ªõi s·∫Ω ƒë∆∞·ª£c th√™m v√†o cu·ªëi; ·∫£nh ƒë·∫°i di·ªán hi·ªán t·∫°i kh√¥ng thay ƒë·ªïi tr·ª´ khi b·∫°n ch·ªçn Avatar ri√™ng.</small>
                    </div>
                </div>


                <div class="d-flex justify-content-center gap-2 mt-4 pt-3 border-top">
                    <a asp-action="Index" class="btn btn-secondary">
                        <i class="bi bi-x-circle me-1"></i>
                        H·ªßy
                    </a>
                    <button type="submit" class="btn btn-primary">
                        <i class="bi bi-check-circle me-1"></i>
                        L∆∞u thay ƒë·ªïi
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>

@section Scripts {
    <script src="~/lib/jquery-validation/dist/jquery.validate.min.js"></script>
    <script>
        // Override jQuery Validation messages to Vietnamese IMMEDIATELY after jQuery Validation loads
        // This MUST happen before unobtrusive validation is loaded
        if (typeof jQuery !== 'undefined' && jQuery.validator) {
            jQuery.extend(jQuery.validator.messages, {
                required: "Tr∆∞·ªùng n√†y l√† b·∫Øt bu·ªôc.",
                remote: "Vui l√≤ng s·ª≠a tr∆∞·ªùng n√†y.",
                email: "Vui l√≤ng nh·∫≠p ƒë·ªãa ch·ªâ email h·ª£p l·ªá.",
                url: "Vui l√≤ng nh·∫≠p URL h·ª£p l·ªá.",
                date: "Vui l√≤ng nh·∫≠p ng√†y h·ª£p l·ªá.",
                dateISO: "Vui l√≤ng nh·∫≠p ng√†y h·ª£p l·ªá (ISO).",
                number: "Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá.",
                digits: "Vui l√≤ng ch·ªâ nh·∫≠p ch·ªØ s·ªë.",
                equalTo: "Vui l√≤ng nh·∫≠p c√πng m·ªôt gi√° tr·ªã.",
                maxlength: jQuery.validator.format("Vui l√≤ng nh·∫≠p kh√¥ng qu√° {0} k√Ω t·ª±."),
                minlength: jQuery.validator.format("Vui l√≤ng nh·∫≠p √≠t nh·∫•t {0} k√Ω t·ª±."),
                rangelength: jQuery.validator.format("Vui l√≤ng nh·∫≠p gi√° tr·ªã t·ª´ {0} ƒë·∫øn {1} k√Ω t·ª±."),
                range: jQuery.validator.format("Vui l√≤ng nh·∫≠p gi√° tr·ªã t·ª´ {0} ƒë·∫øn {1}."),
                max: jQuery.validator.format("Vui l√≤ng nh·∫≠p gi√° tr·ªã nh·ªè h∆°n ho·∫∑c b·∫±ng {0}."),
                min: jQuery.validator.format("Vui l√≤ng nh·∫≠p gi√° tr·ªã l·ªõn h∆°n ho·∫∑c b·∫±ng {0}."),
                step: jQuery.validator.format("Vui l√≤ng nh·∫≠p b·ªôi s·ªë c·ªßa {0}.")
            });
        }
    </script>
    <script src="~/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.min.js"></script>
    <script>
        // Image Preview Function
        function previewImage(input) {
            const preview = document.getElementById('imagePreview');
            const previewImg = document.getElementById('previewImg');
            
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    previewImg.src = e.target.result;
                    preview.style.display = 'block';
                };
                
                reader.readAsDataURL(input.files[0]);
            } else {
                preview.style.display = 'none';
            }
        }
        
        // Xo√° ·∫£nh hi·ªán t·∫°i v√† th√™m input ·∫©n RemoveImages ƒë·ªÉ submit
        document.addEventListener('click', function (e) {
            const btn = e.target.closest('.remove-image-btn');
            if (!btn) return;
            const wrap = btn.closest('.removable-image');
            if (!wrap) return;
            
            // Only process existing images (have data-path), not preview images (have data-preview-index)
            const path = wrap.getAttribute('data-path');
            if (!path) return; // Skip if this is a preview image
            
            const container = document.getElementById('removedImagesContainer');
            if (!container) {
                console.error('‚ùå removedImagesContainer not found!');
                return;
            }
            
            const hidden = document.createElement('input');
            hidden.type = 'hidden';
            hidden.name = 'RemoveImages';
            hidden.value = path;
            container.appendChild(hidden);
            
            console.log('üóëÔ∏è Image removed:', path);
            console.log('üìã RemoveImages inputs count:', container.querySelectorAll('input[name="RemoveImages"]').length);
            
            wrap.remove();
        });

        // Image preview functionality for Edit form
        document.addEventListener('DOMContentLoaded', function() {
            const imageInput = document.getElementById('imageInputEdit');
            const galleryContainer = document.getElementById('imageGalleryContainer');
            let selectedFiles = [];

            if (imageInput && galleryContainer) {
                function addPreviewToGallery() {
                    selectedFiles.forEach((file, index) => {
                        if (!file.type.startsWith('image/')) {
                            return;
                        }

                        // Check if preview already exists
                        const existingPreview = galleryContainer.querySelector(`[data-preview-index="${index}"]`);
                        if (existingPreview) {
                            return;
                        }

                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const imageWrapper = document.createElement('div');
                            imageWrapper.className = 'removable-image';
                            imageWrapper.dataset.previewIndex = index;
                            imageWrapper.innerHTML = `
                                <img src="${e.target.result}" alt="Preview ${index + 1}" />
                                <button type="button" class="btn btn-sm btn-danger remove-image-btn remove-preview-btn" data-index="${index}" title="X√≥a ·∫£nh" aria-label="X√≥a ·∫£nh">
                                    <i class="bi bi-x-lg"></i>
                                </button>
                            `;
                            galleryContainer.appendChild(imageWrapper);
                        };
                        reader.readAsDataURL(file);
                    });
                }

                imageInput.addEventListener('change', function(e) {
                    const newFiles = Array.from(e.target.files);
                    // Merge v·ªõi files hi·ªán c√≥ (n·∫øu c√≥)
                    selectedFiles = [...selectedFiles, ...newFiles];
                    addPreviewToGallery();
                    
                    // Update input files
                    const dt = new DataTransfer();
                    selectedFiles.forEach(file => dt.items.add(file));
                    imageInput.files = dt.files;
                });

                // Remove preview image (only for new preview images, not existing ones)
                galleryContainer.addEventListener('click', function(e) {
                    const removeBtn = e.target.closest('.remove-preview-btn');
                    if (!removeBtn) return;
                    
                    // Make sure this is a preview image, not an existing image
                    const wrapper = removeBtn.closest('[data-preview-index]');
                    if (!wrapper) return; // Existing images have data-path, not data-preview-index

                    const index = parseInt(removeBtn.dataset.index);
                    
                    wrapper.remove();
                    
                    // Remove file from array
                    selectedFiles.splice(index, 1);
                    
                    // Update input files
                    const dt = new DataTransfer();
                    selectedFiles.forEach(file => dt.items.add(file));
                    imageInput.files = dt.files;
                    
                    // Re-render all previews with correct indices
                    galleryContainer.querySelectorAll('[data-preview-index]').forEach(el => el.remove());
                    addPreviewToGallery();
                });
            }
        });

        // Helper functions for validation messages in modal
        function showFieldErrorEdit(fieldId, errorId, message) {
            const field = document.getElementById(fieldId);
            const errorDiv = document.getElementById(errorId);
            if (field && errorDiv) {
                field.classList.add('is-invalid');
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
        }

        function hideFieldErrorEdit(fieldId, errorId) {
            const field = document.getElementById(fieldId);
            const errorDiv = document.getElementById(errorId);
            if (field && errorDiv) {
                field.classList.remove('is-invalid');
                errorDiv.style.display = 'none';
            }
        }

        // Routes ƒë·ªÉ l·∫•y options theo tag
        const optionsByTagUrl = '@Url.Action("GetOptions", "Category", new { area = "Admin" })';
        
        // L·∫•y danh s√°ch optionIds v√† tagIds ƒë√£ ch·ªçn t·ª´ model
        const selectedOptionIds = @Html.Raw(Json.Serialize(Model.OptionIds ?? new List<Guid>()));
        const initialTagIds = @Html.Raw(Json.Serialize(Model.TagIds ?? new List<Guid>()));
        const categoryId = '@(ViewBag.CategoryId ?? "")';
        
        // L·∫•y OptionValues t·ª´ ViewBag (n·∫øu c√≥)
        const optionValues = @Html.Raw(Json.Serialize(ViewBag.OptionValues ?? new Dictionary<string, string>()));
        
        // ƒê·∫£m b·∫£o selectedOptionIds lu√¥n l√† array
        if (!Array.isArray(selectedOptionIds)) {
            console.warn('[Edit] selectedOptionIds is not an array:', selectedOptionIds);
        }

        let availableTags = [];
        let selectedTag = null; // Ch·ªâ l∆∞u 1 tag ƒë√£ ch·ªçn: {tagId, name}

        // Load tags v√†o dropdown khi trang load
        async function loadTagsToDropdown() {
            const tagSelect = document.getElementById('tagSelect');
            
            if (!categoryId) {
                tagSelect.innerHTML = '<option value="">-- Kh√¥ng c√≥ danh m·ª•c --</option>';
                tagSelect.disabled = true;
                return;
            }

            tagSelect.disabled = false;
            tagSelect.innerHTML = '<option value="">-- ƒêang t·∫£i tags... --</option>';

            try {
                const response = await fetch(`/Provider/ServiceManagement/GetTagsByCategory?categoryId=${categoryId}`);
                const tags = await response.json();

                availableTags = tags || [];

                if (availableTags.length > 0) {
                    let html = '<option value="">-- Ch·ªçn tag --</option>';
                    availableTags.forEach(function (tag) {
                        // X·ª≠ l√Ω c·∫£ camelCase v√† PascalCase (backend tr·∫£ v·ªÅ PascalCase)
                        const tagId = tag.tagId || tag.TagId || '';
                        const tagName = tag.name || tag.Name || '';
                        
                        // Ch·ªâ th√™m option n·∫øu c√≥ ƒë·∫ßy ƒë·ªß tagId v√† tagName
                        if (tagId && tagName) {
                            html += `<option value="${tagId}" data-tag-name="${tagName}">${tagName}</option>`;
                        } else {
                            console.warn('[Edit] Tag missing id or name:', tag);
                        }
                    });
                    tagSelect.innerHTML = html;
                } else {
                    tagSelect.innerHTML = '<option value="">-- Kh√¥ng c√≥ tags --</option>';
                }
            } catch (error) {
                console.error('Error loading tags:', error);
                tagSelect.innerHTML = '<option value="">-- L·ªói khi t·∫£i tags --</option>';
            }
        }

        // Handle tag selection t·ª´ dropdown
        document.getElementById('tagSelect').addEventListener('change', async function() {
            const tagId = this.value;
            if (!tagId) {
                // N·∫øu ch·ªçn "-- Ch·ªçn tag --", x√≥a tag ƒë√£ ch·ªçn
                if (selectedTag) {
                    removeSelectedTag();
                }
                return;
            }

            const selectedOption = this.options[this.selectedIndex];
            const tagName = selectedOption.getAttribute('data-tag-name');

            // N·∫øu ƒë√£ c√≥ tag ƒë∆∞·ª£c ch·ªçn, x√≥a tag c≈© tr∆∞·ªõc
            if (selectedTag) {
                removeSelectedTag();
            }

            // Ch·ªçn tag m·ªõi
            await setSelectedTag(tagId, tagName);

            // Reset dropdown v·ªÅ "-- Ch·ªçn tag --"
            this.value = '';
        });

        // Handle remove tag button
        document.getElementById('removeSelectedTagBtn').addEventListener('click', function() {
            removeSelectedTag();
            document.getElementById('tagSelect').value = '';
        });

        // Set tag ƒë√£ ch·ªçn
        async function setSelectedTag(tagId, tagName) {
            selectedTag = { tagId, name: tagName };

            // Hi·ªÉn th·ªã tag ƒë√£ ch·ªçn trong khung input (gi·ªëng category)
            const selectedTagDisplay = document.getElementById('selectedTagDisplay');
            const selectedTagName = document.getElementById('selectedTagName');
            const selectedTagIdInput = document.getElementById('selectedTagId');
            const tagSelect = document.getElementById('tagSelect');
            
            selectedTagName.value = tagName;
            selectedTagIdInput.value = tagId;
            selectedTagDisplay.classList.remove('d-none');
            tagSelect.classList.add('d-none');

            // Clear validation error for tag
            tagSelect.classList.remove('is-invalid');

            // Load options cho tag n√†y
            const selectedOptionsContainer = document.getElementById('selectedOptionsContainer');
            await loadOptionsForTag(tagId, tagName, selectedOptionsContainer);

            // Hi·ªÉn th·ªã section options
            document.getElementById('selectedOptionsSection').style.display = 'block';

            // C·∫≠p nh·∫≠t t√™n d·ªãch v·ª•
            updateServiceTitleFromTags();
        }

        // X√≥a tag ƒë√£ ch·ªçn
        function removeSelectedTag() {
            if (!selectedTag) return;

            // ·∫®n hi·ªÉn th·ªã tag ƒë√£ ch·ªçn v√† hi·ªÉn th·ªã l·∫°i dropdown
            const selectedTagDisplay = document.getElementById('selectedTagDisplay');
            const selectedTagIdInput = document.getElementById('selectedTagId');
            const tagSelect = document.getElementById('tagSelect');
            
            selectedTagDisplay.classList.add('d-none');
            tagSelect.classList.remove('d-none');
            selectedTagIdInput.value = '';

            // X√≥a t·∫•t c·∫£ options
            const selectedOptionsContainer = document.getElementById('selectedOptionsContainer');
            selectedOptionsContainer.innerHTML = '';

            // ·∫®n section options
            document.getElementById('selectedOptionsSection').style.display = 'none';

            // X√≥a tag kh·ªèi bi·∫øn
            selectedTag = null;

            // C·∫≠p nh·∫≠t t√™n d·ªãch v·ª•
            updateServiceTitleFromTags();
        }

        // Function ƒë·ªÉ c·∫≠p nh·∫≠t t√™n d·ªãch v·ª• t·ª´ tag ƒë√£ ch·ªçn
        function updateServiceTitleFromTags() {
            const titleInput = document.getElementById('titleInput');
            if (!titleInput) return;

            if (selectedTag) {
                // L·∫•y t√™n c·ªßa tag ƒë√£ ch·ªçn
                titleInput.value = selectedTag.name;
            } else {
                // N·∫øu kh√¥ng c√≥ tag n√†o ƒë∆∞·ª£c ch·ªçn, ƒë·ªÉ tr·ªëng
                titleInput.value = '';
            }
        }

        // Load options cho m·ªôt tag (th√™m v√†o container chung)
        async function loadOptionsForTag(tagId, tagName, optionsContainer) {
            // X√≥a t·∫•t c·∫£ options c≈© tr∆∞·ªõc khi load m·ªõi
            optionsContainer.innerHTML = '';
            
            // T·∫°o loading indicator cho tag n√†y
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'text-muted small mb-2';
            loadingDiv.id = `loading-${tagId}`;
            loadingDiv.dataset.tagId = tagId;
            loadingDiv.innerHTML = `<i class="bi bi-hourglass-split me-1"></i>ƒêang t·∫£i t√πy ch·ªçn cho "${tagName}"...`;
            optionsContainer.appendChild(loadingDiv);
            
            try {
                const res = await fetch(`${optionsByTagUrl}?tagId=${tagId}`);
                if (!res.ok) {
                    loadingDiv.innerHTML = `<div class="text-danger small"><i class="bi bi-exclamation-triangle me-1"></i>L·ªói khi t·∫£i t√πy ch·ªçn cho "${tagName}".</div>`;
                    return;
                }
                        
                const options = await res.json();
                
                // X√≥a loading indicator
                loadingDiv.remove();
                
                if (!options || options.length === 0) {
                    const noOptionsDiv = document.createElement('div');
                    noOptionsDiv.className = 'text-muted small mb-2';
                    noOptionsDiv.dataset.tagId = tagId;
                    noOptionsDiv.innerHTML = `<i class="bi bi-inbox me-1"></i>Tag "${tagName}" ch∆∞a c√≥ t√πy ch·ªçn n√†o.`;
                    optionsContainer.appendChild(noOptionsDiv);
                    return;
                }
                
                // Render t·∫•t c·∫£ options ƒë∆°n gi·∫£n nh∆∞ checkbox
                // Chuy·ªÉn selectedOptionIds sang array of strings ƒë·ªÉ so s√°nh (x·ª≠ l√Ω c·∫£ Guid v√† string)
                const selectedOptionIdsStr = Array.isArray(selectedOptionIds) 
                    ? selectedOptionIds.map(id => String(id || '').toLowerCase().trim())
                    : [];
                
                // Debug log
                console.log('[Edit] Loading options for tag:', tagName);
                console.log('[Edit] Options from API:', options);
                console.log('[Edit] Selected option IDs (raw):', selectedOptionIds);
                console.log('[Edit] Selected option IDs (normalized):', selectedOptionIdsStr);
                
                options.forEach(o => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'mb-3';
                    optionDiv.dataset.tagId = tagId;
                    optionDiv.dataset.optionId = o.optionId || o.OptionId || '';
                    
                    // X·ª≠ l√Ω c·∫£ camelCase v√† PascalCase t·ª´ API response
                    const optionIdValue = o.optionId || o.OptionId || '';
                    const optionNameValue = o.optionName || o.OptionName || '';
                    
                    // So s√°nh optionId (c√≥ th·ªÉ l√† Guid ho·∫∑c string) v·ªõi selectedOptionIds
                    const optionIdStr = String(optionIdValue).toLowerCase().trim();
                    const isChecked = selectedOptionIdsStr.includes(optionIdStr);
                    
                    // L·∫•y gi√° tr·ªã m√¥ t·∫£ c≈© t·ª´ optionValues (n·∫øu c√≥)
                    const existingValue = optionValues && optionValues[optionIdValue] ? optionValues[optionIdValue] : '';
                    const shouldShowDescription = isChecked && existingValue;
                    
                    // Debug log cho t·ª´ng option
                    if (isChecked) {
                        console.log('[Edit] Option matched:', optionNameValue, 'ID:', optionIdValue, 'Normalized:', optionIdStr);
                    }
                    
                    const uniqueId = `option_${tagId}_${optionIdValue}`;
                    const descriptionId = `option_desc_${tagId}_${optionIdValue}`;
                    
                    optionDiv.innerHTML = `
                        <div class="d-flex align-items-start gap-2">
                            <input class="form-check-input form-check-input-sm mt-1" type="checkbox" name="OptionIds" value="${optionIdValue}" id="${uniqueId}" ${isChecked ? 'checked' : ''} />
                            <div class="flex-grow-1">
                                <label class="form-check-label small" for="${uniqueId}">
                                    <span class="fw-semibold">${optionNameValue}</span>
                                </label>
                                <div id="${descriptionId}" class="mt-2" style="display: ${shouldShowDescription ? 'block' : 'none'};">
                                    <label class="form-label small text-muted">
                                        <i class="bi bi-pencil me-1"></i>M√¥ t·∫£ th√™m (t√πy ch·ªçn)
                                    </label>
                                    <textarea class="form-control form-control-sm" 
                                              name="OptionValues[${optionIdValue}]" 
                                              id="textarea_${optionIdValue}"
                                              rows="2" 
                                              maxlength="200"
                                              placeholder="Nh·∫≠p m√¥ t·∫£ th√™m cho t√πy ch·ªçn n√†y (kh√¥ng b·∫Øt bu·ªôc)..."
                                              style="resize: vertical; min-height: 60px;">${existingValue || ''}</textarea>
                                    <div class="d-flex justify-content-between align-items-center mt-1">
                                        <small class="form-text text-muted" style="font-size: 0.75rem;">B·∫°n c√≥ th·ªÉ m√¥ t·∫£ th√™m chi ti·∫øt v·ªÅ t√πy ch·ªçn n√†y.</small>
                                        <small class="form-text text-muted text-end" id="charCount_${optionIdValue}" style="font-size: 0.75rem;">${(existingValue || '').length}/200 k√Ω t·ª±</small>
                                    </div>
                                </div>
                            </div>
                        </div>`;
                    
                    optionsContainer.appendChild(optionDiv);
                    
                    // Th√™m event listener ƒë·ªÉ hi·ªÉn th·ªã/·∫©n textarea khi checkbox ƒë∆∞·ª£c ch·ªçn/b·ªè ch·ªçn
                    const checkbox = optionDiv.querySelector(`#${uniqueId}`);
                    const descriptionDiv = optionDiv.querySelector(`#${descriptionId}`);
                    const textarea = descriptionDiv.querySelector(`#textarea_${optionIdValue}`);
                    const charCount = descriptionDiv.querySelector(`#charCount_${optionIdValue}`);
                    
                    // C·∫≠p nh·∫≠t s·ªë k√Ω t·ª± khi ng∆∞·ªùi d√πng nh·∫≠p
                    if (textarea && charCount) {
                        // Kh·ªüi t·∫°o counter v·ªõi gi√° tr·ªã hi·ªán t·∫°i
                        const currentLength = (existingValue || '').length;
                        if (currentLength >= 200) {
                            charCount.classList.add('text-danger');
                        }
                        
                        textarea.addEventListener('input', function() {
                            const length = this.value.length;
                            charCount.textContent = `${length}/200 k√Ω t·ª±`;
                            if (length >= 200) {
                                charCount.classList.add('text-danger');
                            } else {
                                charCount.classList.remove('text-danger');
                            }
                        });
                    }
                    
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            descriptionDiv.style.display = 'block';
                        } else {
                            descriptionDiv.style.display = 'none';
                            // X√≥a n·ªôi dung textarea khi b·ªè ch·ªçn
                            if (textarea) {
                                textarea.value = '';
                                if (charCount) {
                                    charCount.textContent = '0/200 k√Ω t·ª±';
                                    charCount.classList.remove('text-danger');
                                }
                            }
                        }
                    });
                });
            } catch (error) {
                console.error('Error loading options:', error);
                loadingDiv.innerHTML = `<div class="text-danger small"><i class="bi bi-exclamation-triangle me-1"></i>L·ªói khi t·∫£i t√πy ch·ªçn cho "${tagName}".</div>`;
            }
        }

        // Load tags v√† options ƒë√£ ch·ªçn khi trang load
        document.addEventListener('DOMContentLoaded', async function() {
            // Load tags v√†o dropdown
            await loadTagsToDropdown();

            // Load tag ƒë√£ ch·ªçn t·ª´ model (ch·ªâ l·∫•y tag ƒë·∫ßu ti√™n v√¨ ch·ªâ ch·ªçn 1)
            if (Array.isArray(initialTagIds) && initialTagIds.length > 0) {
                const firstTagId = initialTagIds[0];
                // C·∫ßn l·∫•y th√¥ng tin tag t·ª´ danh s√°ch availableTags
                try {
                    const response = await fetch(`/Provider/ServiceManagement/GetTagsByCategory?categoryId=${categoryId}`);
                    const tags = await response.json();

                    if (tags && tags.length > 0) {
                        // X·ª≠ l√Ω c·∫£ camelCase v√† PascalCase
                        const tag = tags.find(t => (t.tagId || t.TagId) === firstTagId);
                        if (tag) {
                            const tagId = tag.tagId || tag.TagId || '';
                            const tagName = tag.name || tag.Name || '';
                            if (tagId && tagName) {
                                await setSelectedTag(tagId, tagName);
                            }
                        }
                    }

                    // C·∫≠p nh·∫≠t dropdown sau khi load xong tags
                    await loadTagsToDropdown();
                } catch (error) {
                    console.error('Error loading initial tag:', error);
                }
            }

            // C·∫≠p nh·∫≠t t√™n d·ªãch v·ª• t·ª´ tag ƒë√£ ch·ªçn khi trang load
            updateServiceTitleFromTags();
            
            // Kh·ªüi t·∫°o gi·ªõi h·∫°n khi trang load
            updateBaseUnitLimits();
            
            // Real-time validation - clear errors when user inputs
            // Tag validation
            const tagSelect = document.getElementById('tagSelect');
            if (tagSelect) {
                tagSelect.addEventListener('change', function() {
                    const selectedTagId = document.getElementById('selectedTagId');
                    if (selectedTagId && selectedTagId.value) {
                        this.classList.remove('is-invalid');
                    }
                });
            }
            
            // Function to update description character count
            function updateDescriptionCharCount(textarea) {
                const charCount = document.getElementById('descriptionCharCount');
                if (charCount) {
                    const length = textarea.value.length;
                    charCount.textContent = `${length}/3000 k√Ω t·ª±`;
                    if (length >= 3000) {
                        charCount.classList.add('text-danger');
                    } else {
                        charCount.classList.remove('text-danger');
                    }
                }
            }
            
            // Description validation
            const descriptionField = document.getElementById('Description');
            if (descriptionField) {
                // Initialize character count
                updateDescriptionCharCount(descriptionField);
                
                descriptionField.addEventListener('input', function() {
                    if (this.value && this.value.trim()) {
                        this.classList.remove('is-invalid');
                    }
                    updateDescriptionCharCount(this);
                });
            }
            
            // Enhanced validation for Price - t·ª´ 20,000 ƒë·∫øn 100 tri·ªáu
            const priceField = document.getElementById('Price');
            if (priceField) {
                function validatePrice() {
                    const value = parseFloat(priceField.value);
                    const minPrice = 20000;
                    const maxPrice = 100000000;
                    
                    if (!priceField.value || priceField.value.trim() === '') {
                        priceField.setCustomValidity('Vui l√≤ng nh·∫≠p gi√° d·ªãch v·ª•.');
                        priceField.classList.add('is-invalid');
                    } else if (isNaN(value)) {
                        priceField.setCustomValidity('Gi√° ph·∫£i l√† s·ªë h·ª£p l·ªá.');
                        priceField.classList.add('is-invalid');
                    } else if (value < 0) {
                        priceField.setCustomValidity('Gi√° kh√¥ng ƒë∆∞·ª£c l√† s·ªë √¢m.');
                        priceField.classList.add('is-invalid');
                    } else if (value < minPrice) {
                        priceField.setCustomValidity(`Gi√° t·ªëi thi·ªÉu l√† ${minPrice.toLocaleString('vi-VN')} VNƒê.`);
                        priceField.classList.add('is-invalid');
                    } else if (value > maxPrice) {
                        priceField.setCustomValidity(`Gi√° t·ªëi ƒëa l√† ${maxPrice.toLocaleString('vi-VN')} VNƒê.`);
                        priceField.classList.add('is-invalid');
                    } else if (value % 1000 !== 0) {
                        priceField.setCustomValidity('Gi√° ph·∫£i l√† b·ªôi s·ªë c·ªßa 1.000 VNƒê (v√≠ d·ª•: 20.000, 50.000, 100.000).');
                        priceField.classList.add('is-invalid');
                    } else {
                        priceField.setCustomValidity('');
                        priceField.classList.remove('is-invalid');
                    }
                }

                priceField.addEventListener('input', validatePrice);
                priceField.addEventListener('blur', validatePrice);
                priceField.addEventListener('change', validatePrice);
            }
            
            // UnitType validation - c·∫≠p nh·∫≠t gi·ªõi h·∫°n BaseUnit khi ƒë∆°n v·ªã thay ƒë·ªïi
            const unitTypeSelect = document.getElementById('unitTypeSelect');
            if (unitTypeSelect) {
                unitTypeSelect.addEventListener('change', function() {
                    if (this.value) {
                        this.classList.remove('is-invalid');
                        // C·∫≠p nh·∫≠t gi·ªõi h·∫°n cho BaseUnit
                        updateBaseUnitLimits();
                    }
                });
            }
            
            // BaseUnit validation v·ªõi gi·ªõi h·∫°n theo ƒë∆°n v·ªã
            const baseUnitField = document.getElementById('BaseUnit');
            if (baseUnitField) {
                baseUnitField.addEventListener('input', function() {
                    validateBaseUnitWithUnitType(this);
                });
                
                baseUnitField.addEventListener('blur', function() {
                    validateBaseUnitWithUnitType(this);
                });
            }
        });

        // Handle form submit ƒë·ªÉ preserve images
        document.addEventListener('DOMContentLoaded', function() {

            // Handle form submit to ensure old images are preserved when no new images are uploaded
            const editForm = document.getElementById('editServiceForm');
            if (editForm) {
                editForm.addEventListener('submit', function(e) {
                    let isValid = true;
                    
                    // Clear all errors first
                    document.querySelectorAll('.is-invalid').forEach(el => el.classList.remove('is-invalid'));
                    
                    // Validate Tag
                    const selectedTagId = document.getElementById('selectedTagId');
                    if (!selectedTagId || !selectedTagId.value) {
                        const tagSelect = document.getElementById('tagSelect');
                        if (tagSelect) {
                            tagSelect.classList.add('is-invalid');
                        }
                        isValid = false;
                    }
                    
                    // Validate Description
                    const descriptionField = document.getElementById('Description');
                    if (!descriptionField || !descriptionField.value || !descriptionField.value.trim()) {
                        if (descriptionField) descriptionField.classList.add('is-invalid');
                        isValid = false;
                    }
                    
                    // Validate Price
                    const priceField = document.getElementById('Price');
                    if (!priceField || !priceField.value || priceField.value.trim() === '') {
                        if (priceField) {
                            priceField.setCustomValidity('Vui l√≤ng nh·∫≠p gi√° d·ªãch v·ª•.');
                            priceField.classList.add('is-invalid');
                        }
                        isValid = false;
                    } else {
                        const price = parseFloat(priceField.value);
                        const minPrice = 20000;
                        const maxPrice = 100000000;
                        
                        if (isNaN(price)) {
                            priceField.setCustomValidity('Gi√° ph·∫£i l√† s·ªë h·ª£p l·ªá.');
                            priceField.classList.add('is-invalid');
                            isValid = false;
                        } else if (price < 0) {
                            priceField.setCustomValidity('Gi√° kh√¥ng ƒë∆∞·ª£c l√† s·ªë √¢m.');
                            priceField.classList.add('is-invalid');
                            isValid = false;
                        } else if (price < minPrice) {
                            priceField.setCustomValidity(`Gi√° t·ªëi thi·ªÉu l√† ${minPrice.toLocaleString('vi-VN')} VNƒê.`);
                            priceField.classList.add('is-invalid');
                            isValid = false;
                        } else if (price > maxPrice) {
                            priceField.setCustomValidity(`Gi√° t·ªëi ƒëa l√† ${maxPrice.toLocaleString('vi-VN')} VNƒê.`);
                            priceField.classList.add('is-invalid');
                            isValid = false;
                        } else if (price % 1000 !== 0) {
                            priceField.setCustomValidity('Gi√° ph·∫£i l√† b·ªôi s·ªë c·ªßa 1.000 VNƒê (v√≠ d·ª•: 20.000, 50.000, 100.000).');
                            priceField.classList.add('is-invalid');
                            isValid = false;
                        } else {
                            priceField.setCustomValidity('');
                            priceField.classList.remove('is-invalid');
                        }
                    }
                    
                    // Validate UnitType
                    const unitTypeSelect = document.getElementById('unitTypeSelect');
                    if (!unitTypeSelect || !unitTypeSelect.value) {
                        if (unitTypeSelect) unitTypeSelect.classList.add('is-invalid');
                        isValid = false;
                    }
                    
                    // Validate BaseUnit v·ªõi gi·ªõi h·∫°n theo ƒë∆°n v·ªã
                    const baseUnitField = document.getElementById('BaseUnit');
                    if (baseUnitField) {
                        if (unitTypeSelect && unitTypeSelect.value) {
                            const unitType = unitTypeSelect.value;
                            const limits = getUnitLimits(unitType);
                            const value = parseFloat(baseUnitField.value);
                            
                            if (!baseUnitField.value || isNaN(value) || value < limits.min || value > limits.max) {
                                validateBaseUnitWithUnitType(baseUnitField);
                                isValid = false;
                            }
                        } else if (!baseUnitField.value || parseFloat(baseUnitField.value) < 1) {
                            baseUnitField.classList.add('is-invalid');
                            isValid = false;
                        }
                    }
                    
                    // Validate Options - ph·∫£i ch·ªçn √≠t nh·∫•t m·ªôt t√πy ch·ªçn
                    const selectedOptionsContainer = document.getElementById('selectedOptionsContainer');
                    const selectedOptionsSection = document.getElementById('selectedOptionsSection');
                    const checkedOptions = selectedOptionsContainer ? selectedOptionsContainer.querySelectorAll('input[type="checkbox"][name="OptionIds"]:checked') : [];
                    
                    if (!checkedOptions || checkedOptions.length === 0) {
                        // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói trong section options
                        if (selectedOptionsSection) {
                            selectedOptionsSection.style.display = 'block';
                            let errorDiv = selectedOptionsContainer.querySelector('.options-error-message');
                            if (!errorDiv) {
                                errorDiv = document.createElement('div');
                                errorDiv.className = 'options-error-message alert alert-danger mb-2';
                                errorDiv.innerHTML = '<i class="bi bi-exclamation-triangle me-2"></i>Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt t√πy ch·ªçn.';
                                selectedOptionsContainer.insertBefore(errorDiv, selectedOptionsContainer.firstChild);
                            } else {
                                errorDiv.style.display = 'block';
                            }
                        }
                        isValid = false;
                    } else {
                        // X√≥a th√¥ng b√°o l·ªói n·∫øu ƒë√£ ch·ªçn
                        const errorDiv = selectedOptionsContainer ? selectedOptionsContainer.querySelector('.options-error-message') : null;
                        if (errorDiv) {
                            errorDiv.remove();
                        }
                    }
                    
                    // Ch·ªâ ch·∫∑n submit n·∫øu kh√¥ng h·ª£p l·ªá
                    if (!isValid) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Focus v√†o tr∆∞·ªùng l·ªói ƒë·∫ßu ti√™n
                        const firstInvalid = document.querySelector('.is-invalid');
                        if (firstInvalid) {
                            setTimeout(() => {
                                firstInvalid.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                if (firstInvalid.focus) {
                                    firstInvalid.focus();
                                }
                            }, 100);
                        }
                        
                        return false;
                    }
                    
                    const imageInput = document.getElementById('imageInputEdit');
                    const currentImagesData = document.getElementById('currentImagesData');
                    const removedImagesContainer = document.getElementById('removedImagesContainer');
                    
                    // Get current images list
                    const currentImagesStr = currentImagesData ? currentImagesData.value : '';
                    const currentImages = currentImagesStr 
                        ? currentImagesStr.split(',').map(img => img.trim()).filter(img => img.length > 0)
                        : [];
                    
                    // Get removed images list
                    const removedInputs = removedImagesContainer ? removedImagesContainer.querySelectorAll('input[name="RemoveImages"]') : [];
                    const removedImages = Array.from(removedInputs).map(input => input.value.trim()).filter(img => img.length > 0);
                    
                    // Debug log
                    console.log('üì§ Form submit - RemoveImages:', removedImages);
                    console.log('üì§ Form submit - RemoveImages count:', removedImages.length);
                    console.log('üì§ Form submit - Current images:', currentImages);
                    
                    // Calculate remaining images (current - removed)
                    // Normalize paths for comparison (remove leading/trailing slashes)
                    const normalizePath = (path) => path.trim().replace(/^\/+|\/+$/g, '');
                    const normalizedRemoved = removedImages.map(normalizePath);
                    const remainingImages = currentImages.filter(img => {
                        const normalizedImg = normalizePath(img);
                        return !normalizedRemoved.includes(normalizedImg);
                    });
                    
                    // Check if there are new images being uploaded
                    const hasNewImages = imageInput && imageInput.files && imageInput.files.length > 0;
                    
                    // If no new images are uploaded, send the remaining images as KeepImages
                    // This ensures backend knows which old images to preserve
                    if (!hasNewImages && remainingImages.length > 0) {
                        // Remove any existing KeepImages inputs
                        const existingKeepImages = document.querySelectorAll('input[name="KeepImages"]');
                        existingKeepImages.forEach(input => input.remove());
                        
                        // Add hidden inputs for images to keep
                        remainingImages.forEach(imgPath => {
                            if (imgPath && imgPath.trim().length > 0) {
                                const hiddenInput = document.createElement('input');
                                hiddenInput.type = 'hidden';
                                hiddenInput.name = 'KeepImages';
                                hiddenInput.value = imgPath.trim();
                                removedImagesContainer.appendChild(hiddenInput);
                            }
                        });
                    }
                });
            }
            
            // X√≥a th√¥ng b√°o l·ªói options khi ng∆∞·ªùi d√πng ch·ªçn option
            const selectedOptionsContainer = document.getElementById('selectedOptionsContainer');
            if (selectedOptionsContainer) {
                selectedOptionsContainer.addEventListener('change', function(e) {
                    if (e.target && e.target.type === 'checkbox' && e.target.name === 'OptionIds' && e.target.checked) {
                        const errorDiv = selectedOptionsContainer.querySelector('.options-error-message');
                        if (errorDiv) {
                            errorDiv.remove();
                        }
                    }
                });
            }
        });
    </script>
    
}

